// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v3.19.6
// source: nodes.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "lenga";

export interface Node {
  node?:
    | { $case: "unknownNode"; unknownNode: UnknownNode }
    | { $case: "declNode"; declNode: DeclNode }
    | { $case: "stmtNode"; stmtNode: StmtNode }
    | { $case: "exprNode"; exprNode: ExprNode }
    | undefined;
}

export interface UnknownNode {
  id: string;
  contents: string;
}

export interface DeclNode {
  declaration?:
    | { $case: "includeDecl"; includeDecl: IncludeDecl }
    | { $case: "funcDecl"; funcDecl: FuncDecl }
    | { $case: "varDecl"; varDecl: VarDecl }
    | { $case: "paramDecl"; paramDecl: ParamDecl }
    | undefined;
}

export interface StmtNode {
  statement?: { $case: "compStmt"; compStmt: CompStmt } | { $case: "returnStmt"; returnStmt: ReturnStmt } | undefined;
}

export interface ExprNode {
  expression?:
    | { $case: "callExpr"; callExpr: CallExpr }
    | { $case: "declRefExpr"; declRefExpr: DeclRefExpr }
    | { $case: "assignmentExpr"; assignmentExpr: AssignmentExpr }
    | { $case: "literalExpr"; literalExpr: LiteralExpr }
    | { $case: "identifierExpr"; identifierExpr: IdentifierExpr }
    | undefined;
}

export interface IncludeDecl {
  id: string;
  directive: string;
}

export interface FuncDecl {
  id: string;
  name: string;
  returnType: string;
  params: ParamDecl[];
  body?: CompStmt | undefined;
}

export interface ParamDecl {
  id: string;
  name: string;
  dataType: string;
}

export interface VarDecl {
  id: string;
  name: string;
  dataType: string;
  initializer?: ExprNode | undefined;
}

export interface ReturnStmt {
  id: string;
  expression?: ExprNode | undefined;
}

export interface CompStmt {
  id: string;
  statements: Node[];
}

export interface CallExpr {
  id: string;
  calle?: ExprNode | undefined;
  args: ExprNode[];
}

export interface DeclRefExpr {
  id: string;
  declRefId: string;
}

export interface AssignmentExpr {
  id: string;
  left?: ExprNode | undefined;
  right?: ExprNode | undefined;
  op: string;
}

export interface LiteralExpr {
  id: string;
  dataType: string;
  value: string;
}

export interface IdentifierExpr {
  id: string;
  identifier: string;
}

function createBaseNode(): Node {
  return { node: undefined };
}

export const Node: MessageFns<Node> = {
  encode(message: Node, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.node?.$case) {
      case "unknownNode":
        UnknownNode.encode(message.node.unknownNode, writer.uint32(10).fork()).join();
        break;
      case "declNode":
        DeclNode.encode(message.node.declNode, writer.uint32(18).fork()).join();
        break;
      case "stmtNode":
        StmtNode.encode(message.node.stmtNode, writer.uint32(26).fork()).join();
        break;
      case "exprNode":
        ExprNode.encode(message.node.exprNode, writer.uint32(34).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Node {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.node = { $case: "unknownNode", unknownNode: UnknownNode.decode(reader, reader.uint32()) };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.node = { $case: "declNode", declNode: DeclNode.decode(reader, reader.uint32()) };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.node = { $case: "stmtNode", stmtNode: StmtNode.decode(reader, reader.uint32()) };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.node = { $case: "exprNode", exprNode: ExprNode.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Node {
    return {
      node: isSet(object.unknownNode)
        ? { $case: "unknownNode", unknownNode: UnknownNode.fromJSON(object.unknownNode) }
        : isSet(object.declNode)
        ? { $case: "declNode", declNode: DeclNode.fromJSON(object.declNode) }
        : isSet(object.stmtNode)
        ? { $case: "stmtNode", stmtNode: StmtNode.fromJSON(object.stmtNode) }
        : isSet(object.exprNode)
        ? { $case: "exprNode", exprNode: ExprNode.fromJSON(object.exprNode) }
        : undefined,
    };
  },

  toJSON(message: Node): unknown {
    const obj: any = {};
    if (message.node?.$case === "unknownNode") {
      obj.unknownNode = UnknownNode.toJSON(message.node.unknownNode);
    } else if (message.node?.$case === "declNode") {
      obj.declNode = DeclNode.toJSON(message.node.declNode);
    } else if (message.node?.$case === "stmtNode") {
      obj.stmtNode = StmtNode.toJSON(message.node.stmtNode);
    } else if (message.node?.$case === "exprNode") {
      obj.exprNode = ExprNode.toJSON(message.node.exprNode);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Node>, I>>(base?: I): Node {
    return Node.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Node>, I>>(object: I): Node {
    const message = createBaseNode();
    switch (object.node?.$case) {
      case "unknownNode": {
        if (object.node?.unknownNode !== undefined && object.node?.unknownNode !== null) {
          message.node = { $case: "unknownNode", unknownNode: UnknownNode.fromPartial(object.node.unknownNode) };
        }
        break;
      }
      case "declNode": {
        if (object.node?.declNode !== undefined && object.node?.declNode !== null) {
          message.node = { $case: "declNode", declNode: DeclNode.fromPartial(object.node.declNode) };
        }
        break;
      }
      case "stmtNode": {
        if (object.node?.stmtNode !== undefined && object.node?.stmtNode !== null) {
          message.node = { $case: "stmtNode", stmtNode: StmtNode.fromPartial(object.node.stmtNode) };
        }
        break;
      }
      case "exprNode": {
        if (object.node?.exprNode !== undefined && object.node?.exprNode !== null) {
          message.node = { $case: "exprNode", exprNode: ExprNode.fromPartial(object.node.exprNode) };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseUnknownNode(): UnknownNode {
  return { id: "", contents: "" };
}

export const UnknownNode: MessageFns<UnknownNode> = {
  encode(message: UnknownNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.contents !== "") {
      writer.uint32(18).string(message.contents);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnknownNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnknownNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contents = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnknownNode {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      contents: isSet(object.contents) ? globalThis.String(object.contents) : "",
    };
  },

  toJSON(message: UnknownNode): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.contents !== "") {
      obj.contents = message.contents;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnknownNode>, I>>(base?: I): UnknownNode {
    return UnknownNode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnknownNode>, I>>(object: I): UnknownNode {
    const message = createBaseUnknownNode();
    message.id = object.id ?? "";
    message.contents = object.contents ?? "";
    return message;
  },
};

function createBaseDeclNode(): DeclNode {
  return { declaration: undefined };
}

export const DeclNode: MessageFns<DeclNode> = {
  encode(message: DeclNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.declaration?.$case) {
      case "includeDecl":
        IncludeDecl.encode(message.declaration.includeDecl, writer.uint32(10).fork()).join();
        break;
      case "funcDecl":
        FuncDecl.encode(message.declaration.funcDecl, writer.uint32(18).fork()).join();
        break;
      case "varDecl":
        VarDecl.encode(message.declaration.varDecl, writer.uint32(26).fork()).join();
        break;
      case "paramDecl":
        ParamDecl.encode(message.declaration.paramDecl, writer.uint32(34).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeclNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeclNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.declaration = { $case: "includeDecl", includeDecl: IncludeDecl.decode(reader, reader.uint32()) };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.declaration = { $case: "funcDecl", funcDecl: FuncDecl.decode(reader, reader.uint32()) };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.declaration = { $case: "varDecl", varDecl: VarDecl.decode(reader, reader.uint32()) };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.declaration = { $case: "paramDecl", paramDecl: ParamDecl.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeclNode {
    return {
      declaration: isSet(object.includeDecl)
        ? { $case: "includeDecl", includeDecl: IncludeDecl.fromJSON(object.includeDecl) }
        : isSet(object.funcDecl)
        ? { $case: "funcDecl", funcDecl: FuncDecl.fromJSON(object.funcDecl) }
        : isSet(object.varDecl)
        ? { $case: "varDecl", varDecl: VarDecl.fromJSON(object.varDecl) }
        : isSet(object.paramDecl)
        ? { $case: "paramDecl", paramDecl: ParamDecl.fromJSON(object.paramDecl) }
        : undefined,
    };
  },

  toJSON(message: DeclNode): unknown {
    const obj: any = {};
    if (message.declaration?.$case === "includeDecl") {
      obj.includeDecl = IncludeDecl.toJSON(message.declaration.includeDecl);
    } else if (message.declaration?.$case === "funcDecl") {
      obj.funcDecl = FuncDecl.toJSON(message.declaration.funcDecl);
    } else if (message.declaration?.$case === "varDecl") {
      obj.varDecl = VarDecl.toJSON(message.declaration.varDecl);
    } else if (message.declaration?.$case === "paramDecl") {
      obj.paramDecl = ParamDecl.toJSON(message.declaration.paramDecl);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeclNode>, I>>(base?: I): DeclNode {
    return DeclNode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeclNode>, I>>(object: I): DeclNode {
    const message = createBaseDeclNode();
    switch (object.declaration?.$case) {
      case "includeDecl": {
        if (object.declaration?.includeDecl !== undefined && object.declaration?.includeDecl !== null) {
          message.declaration = {
            $case: "includeDecl",
            includeDecl: IncludeDecl.fromPartial(object.declaration.includeDecl),
          };
        }
        break;
      }
      case "funcDecl": {
        if (object.declaration?.funcDecl !== undefined && object.declaration?.funcDecl !== null) {
          message.declaration = { $case: "funcDecl", funcDecl: FuncDecl.fromPartial(object.declaration.funcDecl) };
        }
        break;
      }
      case "varDecl": {
        if (object.declaration?.varDecl !== undefined && object.declaration?.varDecl !== null) {
          message.declaration = { $case: "varDecl", varDecl: VarDecl.fromPartial(object.declaration.varDecl) };
        }
        break;
      }
      case "paramDecl": {
        if (object.declaration?.paramDecl !== undefined && object.declaration?.paramDecl !== null) {
          message.declaration = { $case: "paramDecl", paramDecl: ParamDecl.fromPartial(object.declaration.paramDecl) };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseStmtNode(): StmtNode {
  return { statement: undefined };
}

export const StmtNode: MessageFns<StmtNode> = {
  encode(message: StmtNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.statement?.$case) {
      case "compStmt":
        CompStmt.encode(message.statement.compStmt, writer.uint32(10).fork()).join();
        break;
      case "returnStmt":
        ReturnStmt.encode(message.statement.returnStmt, writer.uint32(18).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StmtNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStmtNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.statement = { $case: "compStmt", compStmt: CompStmt.decode(reader, reader.uint32()) };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.statement = { $case: "returnStmt", returnStmt: ReturnStmt.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StmtNode {
    return {
      statement: isSet(object.compStmt)
        ? { $case: "compStmt", compStmt: CompStmt.fromJSON(object.compStmt) }
        : isSet(object.returnStmt)
        ? { $case: "returnStmt", returnStmt: ReturnStmt.fromJSON(object.returnStmt) }
        : undefined,
    };
  },

  toJSON(message: StmtNode): unknown {
    const obj: any = {};
    if (message.statement?.$case === "compStmt") {
      obj.compStmt = CompStmt.toJSON(message.statement.compStmt);
    } else if (message.statement?.$case === "returnStmt") {
      obj.returnStmt = ReturnStmt.toJSON(message.statement.returnStmt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StmtNode>, I>>(base?: I): StmtNode {
    return StmtNode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StmtNode>, I>>(object: I): StmtNode {
    const message = createBaseStmtNode();
    switch (object.statement?.$case) {
      case "compStmt": {
        if (object.statement?.compStmt !== undefined && object.statement?.compStmt !== null) {
          message.statement = { $case: "compStmt", compStmt: CompStmt.fromPartial(object.statement.compStmt) };
        }
        break;
      }
      case "returnStmt": {
        if (object.statement?.returnStmt !== undefined && object.statement?.returnStmt !== null) {
          message.statement = { $case: "returnStmt", returnStmt: ReturnStmt.fromPartial(object.statement.returnStmt) };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseExprNode(): ExprNode {
  return { expression: undefined };
}

export const ExprNode: MessageFns<ExprNode> = {
  encode(message: ExprNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.expression?.$case) {
      case "callExpr":
        CallExpr.encode(message.expression.callExpr, writer.uint32(10).fork()).join();
        break;
      case "declRefExpr":
        DeclRefExpr.encode(message.expression.declRefExpr, writer.uint32(18).fork()).join();
        break;
      case "assignmentExpr":
        AssignmentExpr.encode(message.expression.assignmentExpr, writer.uint32(26).fork()).join();
        break;
      case "literalExpr":
        LiteralExpr.encode(message.expression.literalExpr, writer.uint32(34).fork()).join();
        break;
      case "identifierExpr":
        IdentifierExpr.encode(message.expression.identifierExpr, writer.uint32(42).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExprNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExprNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.expression = { $case: "callExpr", callExpr: CallExpr.decode(reader, reader.uint32()) };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.expression = { $case: "declRefExpr", declRefExpr: DeclRefExpr.decode(reader, reader.uint32()) };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.expression = {
            $case: "assignmentExpr",
            assignmentExpr: AssignmentExpr.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.expression = { $case: "literalExpr", literalExpr: LiteralExpr.decode(reader, reader.uint32()) };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.expression = {
            $case: "identifierExpr",
            identifierExpr: IdentifierExpr.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExprNode {
    return {
      expression: isSet(object.callExpr)
        ? { $case: "callExpr", callExpr: CallExpr.fromJSON(object.callExpr) }
        : isSet(object.declRefExpr)
        ? { $case: "declRefExpr", declRefExpr: DeclRefExpr.fromJSON(object.declRefExpr) }
        : isSet(object.assignmentExpr)
        ? { $case: "assignmentExpr", assignmentExpr: AssignmentExpr.fromJSON(object.assignmentExpr) }
        : isSet(object.literalExpr)
        ? { $case: "literalExpr", literalExpr: LiteralExpr.fromJSON(object.literalExpr) }
        : isSet(object.identifierExpr)
        ? { $case: "identifierExpr", identifierExpr: IdentifierExpr.fromJSON(object.identifierExpr) }
        : undefined,
    };
  },

  toJSON(message: ExprNode): unknown {
    const obj: any = {};
    if (message.expression?.$case === "callExpr") {
      obj.callExpr = CallExpr.toJSON(message.expression.callExpr);
    } else if (message.expression?.$case === "declRefExpr") {
      obj.declRefExpr = DeclRefExpr.toJSON(message.expression.declRefExpr);
    } else if (message.expression?.$case === "assignmentExpr") {
      obj.assignmentExpr = AssignmentExpr.toJSON(message.expression.assignmentExpr);
    } else if (message.expression?.$case === "literalExpr") {
      obj.literalExpr = LiteralExpr.toJSON(message.expression.literalExpr);
    } else if (message.expression?.$case === "identifierExpr") {
      obj.identifierExpr = IdentifierExpr.toJSON(message.expression.identifierExpr);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExprNode>, I>>(base?: I): ExprNode {
    return ExprNode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExprNode>, I>>(object: I): ExprNode {
    const message = createBaseExprNode();
    switch (object.expression?.$case) {
      case "callExpr": {
        if (object.expression?.callExpr !== undefined && object.expression?.callExpr !== null) {
          message.expression = { $case: "callExpr", callExpr: CallExpr.fromPartial(object.expression.callExpr) };
        }
        break;
      }
      case "declRefExpr": {
        if (object.expression?.declRefExpr !== undefined && object.expression?.declRefExpr !== null) {
          message.expression = {
            $case: "declRefExpr",
            declRefExpr: DeclRefExpr.fromPartial(object.expression.declRefExpr),
          };
        }
        break;
      }
      case "assignmentExpr": {
        if (object.expression?.assignmentExpr !== undefined && object.expression?.assignmentExpr !== null) {
          message.expression = {
            $case: "assignmentExpr",
            assignmentExpr: AssignmentExpr.fromPartial(object.expression.assignmentExpr),
          };
        }
        break;
      }
      case "literalExpr": {
        if (object.expression?.literalExpr !== undefined && object.expression?.literalExpr !== null) {
          message.expression = {
            $case: "literalExpr",
            literalExpr: LiteralExpr.fromPartial(object.expression.literalExpr),
          };
        }
        break;
      }
      case "identifierExpr": {
        if (object.expression?.identifierExpr !== undefined && object.expression?.identifierExpr !== null) {
          message.expression = {
            $case: "identifierExpr",
            identifierExpr: IdentifierExpr.fromPartial(object.expression.identifierExpr),
          };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseIncludeDecl(): IncludeDecl {
  return { id: "", directive: "" };
}

export const IncludeDecl: MessageFns<IncludeDecl> = {
  encode(message: IncludeDecl, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.directive !== "") {
      writer.uint32(18).string(message.directive);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IncludeDecl {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIncludeDecl();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.directive = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IncludeDecl {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      directive: isSet(object.directive) ? globalThis.String(object.directive) : "",
    };
  },

  toJSON(message: IncludeDecl): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.directive !== "") {
      obj.directive = message.directive;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IncludeDecl>, I>>(base?: I): IncludeDecl {
    return IncludeDecl.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IncludeDecl>, I>>(object: I): IncludeDecl {
    const message = createBaseIncludeDecl();
    message.id = object.id ?? "";
    message.directive = object.directive ?? "";
    return message;
  },
};

function createBaseFuncDecl(): FuncDecl {
  return { id: "", name: "", returnType: "", params: [], body: undefined };
}

export const FuncDecl: MessageFns<FuncDecl> = {
  encode(message: FuncDecl, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.returnType !== "") {
      writer.uint32(26).string(message.returnType);
    }
    for (const v of message.params) {
      ParamDecl.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.body !== undefined) {
      CompStmt.encode(message.body, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FuncDecl {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFuncDecl();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.returnType = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.params.push(ParamDecl.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.body = CompStmt.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FuncDecl {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      returnType: isSet(object.returnType) ? globalThis.String(object.returnType) : "",
      params: globalThis.Array.isArray(object?.params) ? object.params.map((e: any) => ParamDecl.fromJSON(e)) : [],
      body: isSet(object.body) ? CompStmt.fromJSON(object.body) : undefined,
    };
  },

  toJSON(message: FuncDecl): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.returnType !== "") {
      obj.returnType = message.returnType;
    }
    if (message.params?.length) {
      obj.params = message.params.map((e) => ParamDecl.toJSON(e));
    }
    if (message.body !== undefined) {
      obj.body = CompStmt.toJSON(message.body);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FuncDecl>, I>>(base?: I): FuncDecl {
    return FuncDecl.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FuncDecl>, I>>(object: I): FuncDecl {
    const message = createBaseFuncDecl();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.returnType = object.returnType ?? "";
    message.params = object.params?.map((e) => ParamDecl.fromPartial(e)) || [];
    message.body = (object.body !== undefined && object.body !== null) ? CompStmt.fromPartial(object.body) : undefined;
    return message;
  },
};

function createBaseParamDecl(): ParamDecl {
  return { id: "", name: "", dataType: "" };
}

export const ParamDecl: MessageFns<ParamDecl> = {
  encode(message: ParamDecl, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.dataType !== "") {
      writer.uint32(26).string(message.dataType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParamDecl {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParamDecl();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.dataType = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParamDecl {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      dataType: isSet(object.dataType) ? globalThis.String(object.dataType) : "",
    };
  },

  toJSON(message: ParamDecl): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.dataType !== "") {
      obj.dataType = message.dataType;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ParamDecl>, I>>(base?: I): ParamDecl {
    return ParamDecl.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ParamDecl>, I>>(object: I): ParamDecl {
    const message = createBaseParamDecl();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.dataType = object.dataType ?? "";
    return message;
  },
};

function createBaseVarDecl(): VarDecl {
  return { id: "", name: "", dataType: "", initializer: undefined };
}

export const VarDecl: MessageFns<VarDecl> = {
  encode(message: VarDecl, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.dataType !== "") {
      writer.uint32(26).string(message.dataType);
    }
    if (message.initializer !== undefined) {
      ExprNode.encode(message.initializer, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VarDecl {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVarDecl();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.dataType = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.initializer = ExprNode.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VarDecl {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      dataType: isSet(object.dataType) ? globalThis.String(object.dataType) : "",
      initializer: isSet(object.initializer) ? ExprNode.fromJSON(object.initializer) : undefined,
    };
  },

  toJSON(message: VarDecl): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.dataType !== "") {
      obj.dataType = message.dataType;
    }
    if (message.initializer !== undefined) {
      obj.initializer = ExprNode.toJSON(message.initializer);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VarDecl>, I>>(base?: I): VarDecl {
    return VarDecl.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VarDecl>, I>>(object: I): VarDecl {
    const message = createBaseVarDecl();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.dataType = object.dataType ?? "";
    message.initializer = (object.initializer !== undefined && object.initializer !== null)
      ? ExprNode.fromPartial(object.initializer)
      : undefined;
    return message;
  },
};

function createBaseReturnStmt(): ReturnStmt {
  return { id: "", expression: undefined };
}

export const ReturnStmt: MessageFns<ReturnStmt> = {
  encode(message: ReturnStmt, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.expression !== undefined) {
      ExprNode.encode(message.expression, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReturnStmt {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReturnStmt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.expression = ExprNode.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReturnStmt {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      expression: isSet(object.expression) ? ExprNode.fromJSON(object.expression) : undefined,
    };
  },

  toJSON(message: ReturnStmt): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.expression !== undefined) {
      obj.expression = ExprNode.toJSON(message.expression);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReturnStmt>, I>>(base?: I): ReturnStmt {
    return ReturnStmt.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReturnStmt>, I>>(object: I): ReturnStmt {
    const message = createBaseReturnStmt();
    message.id = object.id ?? "";
    message.expression = (object.expression !== undefined && object.expression !== null)
      ? ExprNode.fromPartial(object.expression)
      : undefined;
    return message;
  },
};

function createBaseCompStmt(): CompStmt {
  return { id: "", statements: [] };
}

export const CompStmt: MessageFns<CompStmt> = {
  encode(message: CompStmt, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    for (const v of message.statements) {
      Node.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CompStmt {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompStmt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.statements.push(Node.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CompStmt {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      statements: globalThis.Array.isArray(object?.statements)
        ? object.statements.map((e: any) => Node.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CompStmt): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.statements?.length) {
      obj.statements = message.statements.map((e) => Node.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CompStmt>, I>>(base?: I): CompStmt {
    return CompStmt.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CompStmt>, I>>(object: I): CompStmt {
    const message = createBaseCompStmt();
    message.id = object.id ?? "";
    message.statements = object.statements?.map((e) => Node.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCallExpr(): CallExpr {
  return { id: "", calle: undefined, args: [] };
}

export const CallExpr: MessageFns<CallExpr> = {
  encode(message: CallExpr, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.calle !== undefined) {
      ExprNode.encode(message.calle, writer.uint32(18).fork()).join();
    }
    for (const v of message.args) {
      ExprNode.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CallExpr {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCallExpr();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.calle = ExprNode.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.args.push(ExprNode.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CallExpr {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      calle: isSet(object.calle) ? ExprNode.fromJSON(object.calle) : undefined,
      args: globalThis.Array.isArray(object?.args) ? object.args.map((e: any) => ExprNode.fromJSON(e)) : [],
    };
  },

  toJSON(message: CallExpr): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.calle !== undefined) {
      obj.calle = ExprNode.toJSON(message.calle);
    }
    if (message.args?.length) {
      obj.args = message.args.map((e) => ExprNode.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CallExpr>, I>>(base?: I): CallExpr {
    return CallExpr.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CallExpr>, I>>(object: I): CallExpr {
    const message = createBaseCallExpr();
    message.id = object.id ?? "";
    message.calle = (object.calle !== undefined && object.calle !== null)
      ? ExprNode.fromPartial(object.calle)
      : undefined;
    message.args = object.args?.map((e) => ExprNode.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDeclRefExpr(): DeclRefExpr {
  return { id: "", declRefId: "" };
}

export const DeclRefExpr: MessageFns<DeclRefExpr> = {
  encode(message: DeclRefExpr, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.declRefId !== "") {
      writer.uint32(18).string(message.declRefId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeclRefExpr {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeclRefExpr();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.declRefId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeclRefExpr {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      declRefId: isSet(object.declRefId) ? globalThis.String(object.declRefId) : "",
    };
  },

  toJSON(message: DeclRefExpr): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.declRefId !== "") {
      obj.declRefId = message.declRefId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeclRefExpr>, I>>(base?: I): DeclRefExpr {
    return DeclRefExpr.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeclRefExpr>, I>>(object: I): DeclRefExpr {
    const message = createBaseDeclRefExpr();
    message.id = object.id ?? "";
    message.declRefId = object.declRefId ?? "";
    return message;
  },
};

function createBaseAssignmentExpr(): AssignmentExpr {
  return { id: "", left: undefined, right: undefined, op: "" };
}

export const AssignmentExpr: MessageFns<AssignmentExpr> = {
  encode(message: AssignmentExpr, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.left !== undefined) {
      ExprNode.encode(message.left, writer.uint32(18).fork()).join();
    }
    if (message.right !== undefined) {
      ExprNode.encode(message.right, writer.uint32(26).fork()).join();
    }
    if (message.op !== "") {
      writer.uint32(34).string(message.op);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssignmentExpr {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssignmentExpr();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.left = ExprNode.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.right = ExprNode.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.op = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AssignmentExpr {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      left: isSet(object.left) ? ExprNode.fromJSON(object.left) : undefined,
      right: isSet(object.right) ? ExprNode.fromJSON(object.right) : undefined,
      op: isSet(object.op) ? globalThis.String(object.op) : "",
    };
  },

  toJSON(message: AssignmentExpr): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.left !== undefined) {
      obj.left = ExprNode.toJSON(message.left);
    }
    if (message.right !== undefined) {
      obj.right = ExprNode.toJSON(message.right);
    }
    if (message.op !== "") {
      obj.op = message.op;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AssignmentExpr>, I>>(base?: I): AssignmentExpr {
    return AssignmentExpr.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AssignmentExpr>, I>>(object: I): AssignmentExpr {
    const message = createBaseAssignmentExpr();
    message.id = object.id ?? "";
    message.left = (object.left !== undefined && object.left !== null) ? ExprNode.fromPartial(object.left) : undefined;
    message.right = (object.right !== undefined && object.right !== null)
      ? ExprNode.fromPartial(object.right)
      : undefined;
    message.op = object.op ?? "";
    return message;
  },
};

function createBaseLiteralExpr(): LiteralExpr {
  return { id: "", dataType: "", value: "" };
}

export const LiteralExpr: MessageFns<LiteralExpr> = {
  encode(message: LiteralExpr, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.dataType !== "") {
      writer.uint32(18).string(message.dataType);
    }
    if (message.value !== "") {
      writer.uint32(26).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LiteralExpr {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLiteralExpr();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.dataType = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LiteralExpr {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      dataType: isSet(object.dataType) ? globalThis.String(object.dataType) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: LiteralExpr): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.dataType !== "") {
      obj.dataType = message.dataType;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LiteralExpr>, I>>(base?: I): LiteralExpr {
    return LiteralExpr.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LiteralExpr>, I>>(object: I): LiteralExpr {
    const message = createBaseLiteralExpr();
    message.id = object.id ?? "";
    message.dataType = object.dataType ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseIdentifierExpr(): IdentifierExpr {
  return { id: "", identifier: "" };
}

export const IdentifierExpr: MessageFns<IdentifierExpr> = {
  encode(message: IdentifierExpr, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.identifier !== "") {
      writer.uint32(18).string(message.identifier);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IdentifierExpr {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIdentifierExpr();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.identifier = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IdentifierExpr {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      identifier: isSet(object.identifier) ? globalThis.String(object.identifier) : "",
    };
  },

  toJSON(message: IdentifierExpr): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.identifier !== "") {
      obj.identifier = message.identifier;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IdentifierExpr>, I>>(base?: I): IdentifierExpr {
    return IdentifierExpr.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IdentifierExpr>, I>>(object: I): IdentifierExpr {
    const message = createBaseIdentifierExpr();
    message.id = object.id ?? "";
    message.identifier = object.identifier ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
