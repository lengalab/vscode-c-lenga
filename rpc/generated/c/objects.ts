// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v3.21.12
// source: c/objects.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "c.lenga";

export interface LanguageObject {
  languageObject?:
    | { $case: "sourceFile"; sourceFile: SourceFile }
    | { $case: "assignmentExpression"; assignmentExpression: AssignmentExpression }
    | { $case: "binaryExpression"; binaryExpression: BinaryExpression }
    | { $case: "callExpression"; callExpression: CallExpression }
    | { $case: "comment"; comment: Comment }
    | { $case: "declaration"; declaration: Declaration }
    | { $case: "elseClause"; elseClause: ElseClause }
    | { $case: "expressionStatement"; expressionStatement: ExpressionStatement }
    | { $case: "functionDeclaration"; functionDeclaration: FunctionDeclaration }
    | { $case: "functionDefinition"; functionDefinition: FunctionDefinition }
    | { $case: "functionParameter"; functionParameter: FunctionParameter }
    | { $case: "ifStatement"; ifStatement: IfStatement }
    | { $case: "numberLiteral"; numberLiteral: NumberLiteral }
    | { $case: "preprocInclude"; preprocInclude: PreprocInclude }
    | { $case: "reference"; reference: Reference }
    | { $case: "returnStatement"; returnStatement: ReturnStatement }
    | { $case: "stringLiteral"; stringLiteral: StringLiteral }
    | { $case: "compoundStatement"; compoundStatement: CompoundStatement }
    | { $case: "unknownNode"; unknownNode: UnknownNode }
    | undefined;
}

export interface SourceFile {
  id: string;
  code: LanguageObject[];
}

export interface UnknownNode {
  id: string;
  contents: string;
}

export interface AssignmentExpression {
  id: string;
  idDeclaration: string;
  identifier: string;
  value?: LanguageObject | undefined;
}

export interface BinaryExpression {
  id: string;
  left?: LanguageObject | undefined;
  operator: string;
  right?: LanguageObject | undefined;
}

export interface CallExpression {
  id: string;
  idDeclaration: string;
  identifier: string;
  argumentList: LanguageObject[];
}

export interface Comment {
  id: string;
  content: string;
}

export interface CompoundStatement {
  id: string;
  codeBlock: LanguageObject[];
}

export interface Declaration {
  id: string;
  /** Assuming CType is serialized as string */
  primitiveType: string;
  identifier: string;
  value?: LanguageObject | undefined;
}

export interface ElseClause {
  id: string;
  condition?: LanguageObject | undefined;
  compoundStatement?: CompoundStatement | undefined;
}

export interface ExpressionStatement {
  id: string;
  identifier: string;
  argumentList: LanguageObject[];
}

export interface FunctionDeclaration {
  id: string;
  /** CType serialized as string */
  returnType: string;
  identifier: string;
  parameterList: FunctionParameter[];
}

export interface FunctionDefinition {
  id: string;
  /** CType serialized as string */
  returnType: string;
  identifier: string;
  parameterList: FunctionParameter[];
  compoundStatement?: CompoundStatement | undefined;
}

export interface FunctionParameter {
  id: string;
  identifier: string;
  /** CType serialized as string */
  paramType: string;
}

export interface IfStatement {
  id: string;
  condition?: LanguageObject | undefined;
  compoundStatement?: CompoundStatement | undefined;
  elseClause?: ElseClause | undefined;
}

export interface NumberLiteral {
  id: string;
  value: string;
}

export interface PreprocInclude {
  id: string;
  content: string;
}

export interface Reference {
  id: string;
  declarationId: string;
  identifier: string;
}

export interface ReturnStatement {
  id: string;
  value?: LanguageObject | undefined;
}

export interface StringLiteral {
  id: string;
  value: string;
}

function createBaseLanguageObject(): LanguageObject {
  return { languageObject: undefined };
}

export const LanguageObject: MessageFns<LanguageObject> = {
  encode(message: LanguageObject, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.languageObject?.$case) {
      case "sourceFile":
        SourceFile.encode(message.languageObject.sourceFile, writer.uint32(10).fork()).join();
        break;
      case "assignmentExpression":
        AssignmentExpression.encode(message.languageObject.assignmentExpression, writer.uint32(18).fork()).join();
        break;
      case "binaryExpression":
        BinaryExpression.encode(message.languageObject.binaryExpression, writer.uint32(26).fork()).join();
        break;
      case "callExpression":
        CallExpression.encode(message.languageObject.callExpression, writer.uint32(34).fork()).join();
        break;
      case "comment":
        Comment.encode(message.languageObject.comment, writer.uint32(42).fork()).join();
        break;
      case "declaration":
        Declaration.encode(message.languageObject.declaration, writer.uint32(50).fork()).join();
        break;
      case "elseClause":
        ElseClause.encode(message.languageObject.elseClause, writer.uint32(58).fork()).join();
        break;
      case "expressionStatement":
        ExpressionStatement.encode(message.languageObject.expressionStatement, writer.uint32(66).fork()).join();
        break;
      case "functionDeclaration":
        FunctionDeclaration.encode(message.languageObject.functionDeclaration, writer.uint32(74).fork()).join();
        break;
      case "functionDefinition":
        FunctionDefinition.encode(message.languageObject.functionDefinition, writer.uint32(82).fork()).join();
        break;
      case "functionParameter":
        FunctionParameter.encode(message.languageObject.functionParameter, writer.uint32(90).fork()).join();
        break;
      case "ifStatement":
        IfStatement.encode(message.languageObject.ifStatement, writer.uint32(98).fork()).join();
        break;
      case "numberLiteral":
        NumberLiteral.encode(message.languageObject.numberLiteral, writer.uint32(106).fork()).join();
        break;
      case "preprocInclude":
        PreprocInclude.encode(message.languageObject.preprocInclude, writer.uint32(114).fork()).join();
        break;
      case "reference":
        Reference.encode(message.languageObject.reference, writer.uint32(122).fork()).join();
        break;
      case "returnStatement":
        ReturnStatement.encode(message.languageObject.returnStatement, writer.uint32(130).fork()).join();
        break;
      case "stringLiteral":
        StringLiteral.encode(message.languageObject.stringLiteral, writer.uint32(138).fork()).join();
        break;
      case "compoundStatement":
        CompoundStatement.encode(message.languageObject.compoundStatement, writer.uint32(146).fork()).join();
        break;
      case "unknownNode":
        UnknownNode.encode(message.languageObject.unknownNode, writer.uint32(3234).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LanguageObject {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLanguageObject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.languageObject = { $case: "sourceFile", sourceFile: SourceFile.decode(reader, reader.uint32()) };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.languageObject = {
            $case: "assignmentExpression",
            assignmentExpression: AssignmentExpression.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.languageObject = {
            $case: "binaryExpression",
            binaryExpression: BinaryExpression.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.languageObject = {
            $case: "callExpression",
            callExpression: CallExpression.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.languageObject = { $case: "comment", comment: Comment.decode(reader, reader.uint32()) };
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.languageObject = { $case: "declaration", declaration: Declaration.decode(reader, reader.uint32()) };
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.languageObject = { $case: "elseClause", elseClause: ElseClause.decode(reader, reader.uint32()) };
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.languageObject = {
            $case: "expressionStatement",
            expressionStatement: ExpressionStatement.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.languageObject = {
            $case: "functionDeclaration",
            functionDeclaration: FunctionDeclaration.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.languageObject = {
            $case: "functionDefinition",
            functionDefinition: FunctionDefinition.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.languageObject = {
            $case: "functionParameter",
            functionParameter: FunctionParameter.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.languageObject = { $case: "ifStatement", ifStatement: IfStatement.decode(reader, reader.uint32()) };
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.languageObject = {
            $case: "numberLiteral",
            numberLiteral: NumberLiteral.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.languageObject = {
            $case: "preprocInclude",
            preprocInclude: PreprocInclude.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.languageObject = { $case: "reference", reference: Reference.decode(reader, reader.uint32()) };
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.languageObject = {
            $case: "returnStatement",
            returnStatement: ReturnStatement.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.languageObject = {
            $case: "stringLiteral",
            stringLiteral: StringLiteral.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.languageObject = {
            $case: "compoundStatement",
            compoundStatement: CompoundStatement.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 404: {
          if (tag !== 3234) {
            break;
          }

          message.languageObject = { $case: "unknownNode", unknownNode: UnknownNode.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LanguageObject {
    return {
      languageObject: isSet(object.sourceFile)
        ? { $case: "sourceFile", sourceFile: SourceFile.fromJSON(object.sourceFile) }
        : isSet(object.assignmentExpression)
        ? {
          $case: "assignmentExpression",
          assignmentExpression: AssignmentExpression.fromJSON(object.assignmentExpression),
        }
        : isSet(object.binaryExpression)
        ? { $case: "binaryExpression", binaryExpression: BinaryExpression.fromJSON(object.binaryExpression) }
        : isSet(object.callExpression)
        ? { $case: "callExpression", callExpression: CallExpression.fromJSON(object.callExpression) }
        : isSet(object.comment)
        ? { $case: "comment", comment: Comment.fromJSON(object.comment) }
        : isSet(object.declaration)
        ? { $case: "declaration", declaration: Declaration.fromJSON(object.declaration) }
        : isSet(object.elseClause)
        ? { $case: "elseClause", elseClause: ElseClause.fromJSON(object.elseClause) }
        : isSet(object.expressionStatement)
        ? {
          $case: "expressionStatement",
          expressionStatement: ExpressionStatement.fromJSON(object.expressionStatement),
        }
        : isSet(object.functionDeclaration)
        ? {
          $case: "functionDeclaration",
          functionDeclaration: FunctionDeclaration.fromJSON(object.functionDeclaration),
        }
        : isSet(object.functionDefinition)
        ? { $case: "functionDefinition", functionDefinition: FunctionDefinition.fromJSON(object.functionDefinition) }
        : isSet(object.functionParameter)
        ? { $case: "functionParameter", functionParameter: FunctionParameter.fromJSON(object.functionParameter) }
        : isSet(object.ifStatement)
        ? { $case: "ifStatement", ifStatement: IfStatement.fromJSON(object.ifStatement) }
        : isSet(object.numberLiteral)
        ? { $case: "numberLiteral", numberLiteral: NumberLiteral.fromJSON(object.numberLiteral) }
        : isSet(object.preprocInclude)
        ? { $case: "preprocInclude", preprocInclude: PreprocInclude.fromJSON(object.preprocInclude) }
        : isSet(object.reference)
        ? { $case: "reference", reference: Reference.fromJSON(object.reference) }
        : isSet(object.returnStatement)
        ? { $case: "returnStatement", returnStatement: ReturnStatement.fromJSON(object.returnStatement) }
        : isSet(object.stringLiteral)
        ? { $case: "stringLiteral", stringLiteral: StringLiteral.fromJSON(object.stringLiteral) }
        : isSet(object.compoundStatement)
        ? { $case: "compoundStatement", compoundStatement: CompoundStatement.fromJSON(object.compoundStatement) }
        : isSet(object.unknownNode)
        ? { $case: "unknownNode", unknownNode: UnknownNode.fromJSON(object.unknownNode) }
        : undefined,
    };
  },

  toJSON(message: LanguageObject): unknown {
    const obj: any = {};
    if (message.languageObject?.$case === "sourceFile") {
      obj.sourceFile = SourceFile.toJSON(message.languageObject.sourceFile);
    } else if (message.languageObject?.$case === "assignmentExpression") {
      obj.assignmentExpression = AssignmentExpression.toJSON(message.languageObject.assignmentExpression);
    } else if (message.languageObject?.$case === "binaryExpression") {
      obj.binaryExpression = BinaryExpression.toJSON(message.languageObject.binaryExpression);
    } else if (message.languageObject?.$case === "callExpression") {
      obj.callExpression = CallExpression.toJSON(message.languageObject.callExpression);
    } else if (message.languageObject?.$case === "comment") {
      obj.comment = Comment.toJSON(message.languageObject.comment);
    } else if (message.languageObject?.$case === "declaration") {
      obj.declaration = Declaration.toJSON(message.languageObject.declaration);
    } else if (message.languageObject?.$case === "elseClause") {
      obj.elseClause = ElseClause.toJSON(message.languageObject.elseClause);
    } else if (message.languageObject?.$case === "expressionStatement") {
      obj.expressionStatement = ExpressionStatement.toJSON(message.languageObject.expressionStatement);
    } else if (message.languageObject?.$case === "functionDeclaration") {
      obj.functionDeclaration = FunctionDeclaration.toJSON(message.languageObject.functionDeclaration);
    } else if (message.languageObject?.$case === "functionDefinition") {
      obj.functionDefinition = FunctionDefinition.toJSON(message.languageObject.functionDefinition);
    } else if (message.languageObject?.$case === "functionParameter") {
      obj.functionParameter = FunctionParameter.toJSON(message.languageObject.functionParameter);
    } else if (message.languageObject?.$case === "ifStatement") {
      obj.ifStatement = IfStatement.toJSON(message.languageObject.ifStatement);
    } else if (message.languageObject?.$case === "numberLiteral") {
      obj.numberLiteral = NumberLiteral.toJSON(message.languageObject.numberLiteral);
    } else if (message.languageObject?.$case === "preprocInclude") {
      obj.preprocInclude = PreprocInclude.toJSON(message.languageObject.preprocInclude);
    } else if (message.languageObject?.$case === "reference") {
      obj.reference = Reference.toJSON(message.languageObject.reference);
    } else if (message.languageObject?.$case === "returnStatement") {
      obj.returnStatement = ReturnStatement.toJSON(message.languageObject.returnStatement);
    } else if (message.languageObject?.$case === "stringLiteral") {
      obj.stringLiteral = StringLiteral.toJSON(message.languageObject.stringLiteral);
    } else if (message.languageObject?.$case === "compoundStatement") {
      obj.compoundStatement = CompoundStatement.toJSON(message.languageObject.compoundStatement);
    } else if (message.languageObject?.$case === "unknownNode") {
      obj.unknownNode = UnknownNode.toJSON(message.languageObject.unknownNode);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LanguageObject>, I>>(base?: I): LanguageObject {
    return LanguageObject.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LanguageObject>, I>>(object: I): LanguageObject {
    const message = createBaseLanguageObject();
    switch (object.languageObject?.$case) {
      case "sourceFile": {
        if (object.languageObject?.sourceFile !== undefined && object.languageObject?.sourceFile !== null) {
          message.languageObject = {
            $case: "sourceFile",
            sourceFile: SourceFile.fromPartial(object.languageObject.sourceFile),
          };
        }
        break;
      }
      case "assignmentExpression": {
        if (
          object.languageObject?.assignmentExpression !== undefined &&
          object.languageObject?.assignmentExpression !== null
        ) {
          message.languageObject = {
            $case: "assignmentExpression",
            assignmentExpression: AssignmentExpression.fromPartial(object.languageObject.assignmentExpression),
          };
        }
        break;
      }
      case "binaryExpression": {
        if (object.languageObject?.binaryExpression !== undefined && object.languageObject?.binaryExpression !== null) {
          message.languageObject = {
            $case: "binaryExpression",
            binaryExpression: BinaryExpression.fromPartial(object.languageObject.binaryExpression),
          };
        }
        break;
      }
      case "callExpression": {
        if (object.languageObject?.callExpression !== undefined && object.languageObject?.callExpression !== null) {
          message.languageObject = {
            $case: "callExpression",
            callExpression: CallExpression.fromPartial(object.languageObject.callExpression),
          };
        }
        break;
      }
      case "comment": {
        if (object.languageObject?.comment !== undefined && object.languageObject?.comment !== null) {
          message.languageObject = { $case: "comment", comment: Comment.fromPartial(object.languageObject.comment) };
        }
        break;
      }
      case "declaration": {
        if (object.languageObject?.declaration !== undefined && object.languageObject?.declaration !== null) {
          message.languageObject = {
            $case: "declaration",
            declaration: Declaration.fromPartial(object.languageObject.declaration),
          };
        }
        break;
      }
      case "elseClause": {
        if (object.languageObject?.elseClause !== undefined && object.languageObject?.elseClause !== null) {
          message.languageObject = {
            $case: "elseClause",
            elseClause: ElseClause.fromPartial(object.languageObject.elseClause),
          };
        }
        break;
      }
      case "expressionStatement": {
        if (
          object.languageObject?.expressionStatement !== undefined &&
          object.languageObject?.expressionStatement !== null
        ) {
          message.languageObject = {
            $case: "expressionStatement",
            expressionStatement: ExpressionStatement.fromPartial(object.languageObject.expressionStatement),
          };
        }
        break;
      }
      case "functionDeclaration": {
        if (
          object.languageObject?.functionDeclaration !== undefined &&
          object.languageObject?.functionDeclaration !== null
        ) {
          message.languageObject = {
            $case: "functionDeclaration",
            functionDeclaration: FunctionDeclaration.fromPartial(object.languageObject.functionDeclaration),
          };
        }
        break;
      }
      case "functionDefinition": {
        if (
          object.languageObject?.functionDefinition !== undefined && object.languageObject?.functionDefinition !== null
        ) {
          message.languageObject = {
            $case: "functionDefinition",
            functionDefinition: FunctionDefinition.fromPartial(object.languageObject.functionDefinition),
          };
        }
        break;
      }
      case "functionParameter": {
        if (
          object.languageObject?.functionParameter !== undefined && object.languageObject?.functionParameter !== null
        ) {
          message.languageObject = {
            $case: "functionParameter",
            functionParameter: FunctionParameter.fromPartial(object.languageObject.functionParameter),
          };
        }
        break;
      }
      case "ifStatement": {
        if (object.languageObject?.ifStatement !== undefined && object.languageObject?.ifStatement !== null) {
          message.languageObject = {
            $case: "ifStatement",
            ifStatement: IfStatement.fromPartial(object.languageObject.ifStatement),
          };
        }
        break;
      }
      case "numberLiteral": {
        if (object.languageObject?.numberLiteral !== undefined && object.languageObject?.numberLiteral !== null) {
          message.languageObject = {
            $case: "numberLiteral",
            numberLiteral: NumberLiteral.fromPartial(object.languageObject.numberLiteral),
          };
        }
        break;
      }
      case "preprocInclude": {
        if (object.languageObject?.preprocInclude !== undefined && object.languageObject?.preprocInclude !== null) {
          message.languageObject = {
            $case: "preprocInclude",
            preprocInclude: PreprocInclude.fromPartial(object.languageObject.preprocInclude),
          };
        }
        break;
      }
      case "reference": {
        if (object.languageObject?.reference !== undefined && object.languageObject?.reference !== null) {
          message.languageObject = {
            $case: "reference",
            reference: Reference.fromPartial(object.languageObject.reference),
          };
        }
        break;
      }
      case "returnStatement": {
        if (object.languageObject?.returnStatement !== undefined && object.languageObject?.returnStatement !== null) {
          message.languageObject = {
            $case: "returnStatement",
            returnStatement: ReturnStatement.fromPartial(object.languageObject.returnStatement),
          };
        }
        break;
      }
      case "stringLiteral": {
        if (object.languageObject?.stringLiteral !== undefined && object.languageObject?.stringLiteral !== null) {
          message.languageObject = {
            $case: "stringLiteral",
            stringLiteral: StringLiteral.fromPartial(object.languageObject.stringLiteral),
          };
        }
        break;
      }
      case "compoundStatement": {
        if (
          object.languageObject?.compoundStatement !== undefined && object.languageObject?.compoundStatement !== null
        ) {
          message.languageObject = {
            $case: "compoundStatement",
            compoundStatement: CompoundStatement.fromPartial(object.languageObject.compoundStatement),
          };
        }
        break;
      }
      case "unknownNode": {
        if (object.languageObject?.unknownNode !== undefined && object.languageObject?.unknownNode !== null) {
          message.languageObject = {
            $case: "unknownNode",
            unknownNode: UnknownNode.fromPartial(object.languageObject.unknownNode),
          };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseSourceFile(): SourceFile {
  return { id: "", code: [] };
}

export const SourceFile: MessageFns<SourceFile> = {
  encode(message: SourceFile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    for (const v of message.code) {
      LanguageObject.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SourceFile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSourceFile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.code.push(LanguageObject.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SourceFile {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      code: globalThis.Array.isArray(object?.code) ? object.code.map((e: any) => LanguageObject.fromJSON(e)) : [],
    };
  },

  toJSON(message: SourceFile): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.code?.length) {
      obj.code = message.code.map((e) => LanguageObject.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SourceFile>, I>>(base?: I): SourceFile {
    return SourceFile.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SourceFile>, I>>(object: I): SourceFile {
    const message = createBaseSourceFile();
    message.id = object.id ?? "";
    message.code = object.code?.map((e) => LanguageObject.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUnknownNode(): UnknownNode {
  return { id: "", contents: "" };
}

export const UnknownNode: MessageFns<UnknownNode> = {
  encode(message: UnknownNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.contents !== "") {
      writer.uint32(18).string(message.contents);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnknownNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnknownNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contents = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnknownNode {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      contents: isSet(object.contents) ? globalThis.String(object.contents) : "",
    };
  },

  toJSON(message: UnknownNode): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.contents !== "") {
      obj.contents = message.contents;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnknownNode>, I>>(base?: I): UnknownNode {
    return UnknownNode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnknownNode>, I>>(object: I): UnknownNode {
    const message = createBaseUnknownNode();
    message.id = object.id ?? "";
    message.contents = object.contents ?? "";
    return message;
  },
};

function createBaseAssignmentExpression(): AssignmentExpression {
  return { id: "", idDeclaration: "", identifier: "", value: undefined };
}

export const AssignmentExpression: MessageFns<AssignmentExpression> = {
  encode(message: AssignmentExpression, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.idDeclaration !== "") {
      writer.uint32(18).string(message.idDeclaration);
    }
    if (message.identifier !== "") {
      writer.uint32(26).string(message.identifier);
    }
    if (message.value !== undefined) {
      LanguageObject.encode(message.value, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssignmentExpression {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssignmentExpression();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.idDeclaration = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.identifier = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.value = LanguageObject.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AssignmentExpression {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      idDeclaration: isSet(object.idDeclaration) ? globalThis.String(object.idDeclaration) : "",
      identifier: isSet(object.identifier) ? globalThis.String(object.identifier) : "",
      value: isSet(object.value) ? LanguageObject.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: AssignmentExpression): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.idDeclaration !== "") {
      obj.idDeclaration = message.idDeclaration;
    }
    if (message.identifier !== "") {
      obj.identifier = message.identifier;
    }
    if (message.value !== undefined) {
      obj.value = LanguageObject.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AssignmentExpression>, I>>(base?: I): AssignmentExpression {
    return AssignmentExpression.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AssignmentExpression>, I>>(object: I): AssignmentExpression {
    const message = createBaseAssignmentExpression();
    message.id = object.id ?? "";
    message.idDeclaration = object.idDeclaration ?? "";
    message.identifier = object.identifier ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? LanguageObject.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseBinaryExpression(): BinaryExpression {
  return { id: "", left: undefined, operator: "", right: undefined };
}

export const BinaryExpression: MessageFns<BinaryExpression> = {
  encode(message: BinaryExpression, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.left !== undefined) {
      LanguageObject.encode(message.left, writer.uint32(18).fork()).join();
    }
    if (message.operator !== "") {
      writer.uint32(26).string(message.operator);
    }
    if (message.right !== undefined) {
      LanguageObject.encode(message.right, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BinaryExpression {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBinaryExpression();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.left = LanguageObject.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.operator = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.right = LanguageObject.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BinaryExpression {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      left: isSet(object.left) ? LanguageObject.fromJSON(object.left) : undefined,
      operator: isSet(object.operator) ? globalThis.String(object.operator) : "",
      right: isSet(object.right) ? LanguageObject.fromJSON(object.right) : undefined,
    };
  },

  toJSON(message: BinaryExpression): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.left !== undefined) {
      obj.left = LanguageObject.toJSON(message.left);
    }
    if (message.operator !== "") {
      obj.operator = message.operator;
    }
    if (message.right !== undefined) {
      obj.right = LanguageObject.toJSON(message.right);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BinaryExpression>, I>>(base?: I): BinaryExpression {
    return BinaryExpression.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BinaryExpression>, I>>(object: I): BinaryExpression {
    const message = createBaseBinaryExpression();
    message.id = object.id ?? "";
    message.left = (object.left !== undefined && object.left !== null)
      ? LanguageObject.fromPartial(object.left)
      : undefined;
    message.operator = object.operator ?? "";
    message.right = (object.right !== undefined && object.right !== null)
      ? LanguageObject.fromPartial(object.right)
      : undefined;
    return message;
  },
};

function createBaseCallExpression(): CallExpression {
  return { id: "", idDeclaration: "", identifier: "", argumentList: [] };
}

export const CallExpression: MessageFns<CallExpression> = {
  encode(message: CallExpression, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.idDeclaration !== "") {
      writer.uint32(18).string(message.idDeclaration);
    }
    if (message.identifier !== "") {
      writer.uint32(26).string(message.identifier);
    }
    for (const v of message.argumentList) {
      LanguageObject.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CallExpression {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCallExpression();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.idDeclaration = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.identifier = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.argumentList.push(LanguageObject.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CallExpression {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      idDeclaration: isSet(object.idDeclaration) ? globalThis.String(object.idDeclaration) : "",
      identifier: isSet(object.identifier) ? globalThis.String(object.identifier) : "",
      argumentList: globalThis.Array.isArray(object?.argumentList)
        ? object.argumentList.map((e: any) => LanguageObject.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CallExpression): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.idDeclaration !== "") {
      obj.idDeclaration = message.idDeclaration;
    }
    if (message.identifier !== "") {
      obj.identifier = message.identifier;
    }
    if (message.argumentList?.length) {
      obj.argumentList = message.argumentList.map((e) => LanguageObject.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CallExpression>, I>>(base?: I): CallExpression {
    return CallExpression.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CallExpression>, I>>(object: I): CallExpression {
    const message = createBaseCallExpression();
    message.id = object.id ?? "";
    message.idDeclaration = object.idDeclaration ?? "";
    message.identifier = object.identifier ?? "";
    message.argumentList = object.argumentList?.map((e) => LanguageObject.fromPartial(e)) || [];
    return message;
  },
};

function createBaseComment(): Comment {
  return { id: "", content: "" };
}

export const Comment: MessageFns<Comment> = {
  encode(message: Comment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.content !== "") {
      writer.uint32(18).string(message.content);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Comment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.content = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Comment {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
    };
  },

  toJSON(message: Comment): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Comment>, I>>(base?: I): Comment {
    return Comment.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Comment>, I>>(object: I): Comment {
    const message = createBaseComment();
    message.id = object.id ?? "";
    message.content = object.content ?? "";
    return message;
  },
};

function createBaseCompoundStatement(): CompoundStatement {
  return { id: "", codeBlock: [] };
}

export const CompoundStatement: MessageFns<CompoundStatement> = {
  encode(message: CompoundStatement, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    for (const v of message.codeBlock) {
      LanguageObject.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CompoundStatement {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompoundStatement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.codeBlock.push(LanguageObject.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CompoundStatement {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      codeBlock: globalThis.Array.isArray(object?.codeBlock)
        ? object.codeBlock.map((e: any) => LanguageObject.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CompoundStatement): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.codeBlock?.length) {
      obj.codeBlock = message.codeBlock.map((e) => LanguageObject.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CompoundStatement>, I>>(base?: I): CompoundStatement {
    return CompoundStatement.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CompoundStatement>, I>>(object: I): CompoundStatement {
    const message = createBaseCompoundStatement();
    message.id = object.id ?? "";
    message.codeBlock = object.codeBlock?.map((e) => LanguageObject.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDeclaration(): Declaration {
  return { id: "", primitiveType: "", identifier: "", value: undefined };
}

export const Declaration: MessageFns<Declaration> = {
  encode(message: Declaration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.primitiveType !== "") {
      writer.uint32(18).string(message.primitiveType);
    }
    if (message.identifier !== "") {
      writer.uint32(26).string(message.identifier);
    }
    if (message.value !== undefined) {
      LanguageObject.encode(message.value, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Declaration {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeclaration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.primitiveType = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.identifier = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.value = LanguageObject.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Declaration {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      primitiveType: isSet(object.primitiveType) ? globalThis.String(object.primitiveType) : "",
      identifier: isSet(object.identifier) ? globalThis.String(object.identifier) : "",
      value: isSet(object.value) ? LanguageObject.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Declaration): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.primitiveType !== "") {
      obj.primitiveType = message.primitiveType;
    }
    if (message.identifier !== "") {
      obj.identifier = message.identifier;
    }
    if (message.value !== undefined) {
      obj.value = LanguageObject.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Declaration>, I>>(base?: I): Declaration {
    return Declaration.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Declaration>, I>>(object: I): Declaration {
    const message = createBaseDeclaration();
    message.id = object.id ?? "";
    message.primitiveType = object.primitiveType ?? "";
    message.identifier = object.identifier ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? LanguageObject.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseElseClause(): ElseClause {
  return { id: "", condition: undefined, compoundStatement: undefined };
}

export const ElseClause: MessageFns<ElseClause> = {
  encode(message: ElseClause, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.condition !== undefined) {
      LanguageObject.encode(message.condition, writer.uint32(18).fork()).join();
    }
    if (message.compoundStatement !== undefined) {
      CompoundStatement.encode(message.compoundStatement, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ElseClause {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseElseClause();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.condition = LanguageObject.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.compoundStatement = CompoundStatement.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ElseClause {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      condition: isSet(object.condition) ? LanguageObject.fromJSON(object.condition) : undefined,
      compoundStatement: isSet(object.compoundStatement)
        ? CompoundStatement.fromJSON(object.compoundStatement)
        : undefined,
    };
  },

  toJSON(message: ElseClause): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.condition !== undefined) {
      obj.condition = LanguageObject.toJSON(message.condition);
    }
    if (message.compoundStatement !== undefined) {
      obj.compoundStatement = CompoundStatement.toJSON(message.compoundStatement);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ElseClause>, I>>(base?: I): ElseClause {
    return ElseClause.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ElseClause>, I>>(object: I): ElseClause {
    const message = createBaseElseClause();
    message.id = object.id ?? "";
    message.condition = (object.condition !== undefined && object.condition !== null)
      ? LanguageObject.fromPartial(object.condition)
      : undefined;
    message.compoundStatement = (object.compoundStatement !== undefined && object.compoundStatement !== null)
      ? CompoundStatement.fromPartial(object.compoundStatement)
      : undefined;
    return message;
  },
};

function createBaseExpressionStatement(): ExpressionStatement {
  return { id: "", identifier: "", argumentList: [] };
}

export const ExpressionStatement: MessageFns<ExpressionStatement> = {
  encode(message: ExpressionStatement, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.identifier !== "") {
      writer.uint32(18).string(message.identifier);
    }
    for (const v of message.argumentList) {
      LanguageObject.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExpressionStatement {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExpressionStatement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.identifier = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.argumentList.push(LanguageObject.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExpressionStatement {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      identifier: isSet(object.identifier) ? globalThis.String(object.identifier) : "",
      argumentList: globalThis.Array.isArray(object?.argumentList)
        ? object.argumentList.map((e: any) => LanguageObject.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ExpressionStatement): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.identifier !== "") {
      obj.identifier = message.identifier;
    }
    if (message.argumentList?.length) {
      obj.argumentList = message.argumentList.map((e) => LanguageObject.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExpressionStatement>, I>>(base?: I): ExpressionStatement {
    return ExpressionStatement.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExpressionStatement>, I>>(object: I): ExpressionStatement {
    const message = createBaseExpressionStatement();
    message.id = object.id ?? "";
    message.identifier = object.identifier ?? "";
    message.argumentList = object.argumentList?.map((e) => LanguageObject.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFunctionDeclaration(): FunctionDeclaration {
  return { id: "", returnType: "", identifier: "", parameterList: [] };
}

export const FunctionDeclaration: MessageFns<FunctionDeclaration> = {
  encode(message: FunctionDeclaration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.returnType !== "") {
      writer.uint32(18).string(message.returnType);
    }
    if (message.identifier !== "") {
      writer.uint32(26).string(message.identifier);
    }
    for (const v of message.parameterList) {
      FunctionParameter.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunctionDeclaration {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunctionDeclaration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.returnType = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.identifier = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.parameterList.push(FunctionParameter.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunctionDeclaration {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      returnType: isSet(object.returnType) ? globalThis.String(object.returnType) : "",
      identifier: isSet(object.identifier) ? globalThis.String(object.identifier) : "",
      parameterList: globalThis.Array.isArray(object?.parameterList)
        ? object.parameterList.map((e: any) => FunctionParameter.fromJSON(e))
        : [],
    };
  },

  toJSON(message: FunctionDeclaration): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.returnType !== "") {
      obj.returnType = message.returnType;
    }
    if (message.identifier !== "") {
      obj.identifier = message.identifier;
    }
    if (message.parameterList?.length) {
      obj.parameterList = message.parameterList.map((e) => FunctionParameter.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FunctionDeclaration>, I>>(base?: I): FunctionDeclaration {
    return FunctionDeclaration.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FunctionDeclaration>, I>>(object: I): FunctionDeclaration {
    const message = createBaseFunctionDeclaration();
    message.id = object.id ?? "";
    message.returnType = object.returnType ?? "";
    message.identifier = object.identifier ?? "";
    message.parameterList = object.parameterList?.map((e) => FunctionParameter.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFunctionDefinition(): FunctionDefinition {
  return { id: "", returnType: "", identifier: "", parameterList: [], compoundStatement: undefined };
}

export const FunctionDefinition: MessageFns<FunctionDefinition> = {
  encode(message: FunctionDefinition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.returnType !== "") {
      writer.uint32(18).string(message.returnType);
    }
    if (message.identifier !== "") {
      writer.uint32(26).string(message.identifier);
    }
    for (const v of message.parameterList) {
      FunctionParameter.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.compoundStatement !== undefined) {
      CompoundStatement.encode(message.compoundStatement, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunctionDefinition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunctionDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.returnType = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.identifier = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.parameterList.push(FunctionParameter.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.compoundStatement = CompoundStatement.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunctionDefinition {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      returnType: isSet(object.returnType) ? globalThis.String(object.returnType) : "",
      identifier: isSet(object.identifier) ? globalThis.String(object.identifier) : "",
      parameterList: globalThis.Array.isArray(object?.parameterList)
        ? object.parameterList.map((e: any) => FunctionParameter.fromJSON(e))
        : [],
      compoundStatement: isSet(object.compoundStatement)
        ? CompoundStatement.fromJSON(object.compoundStatement)
        : undefined,
    };
  },

  toJSON(message: FunctionDefinition): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.returnType !== "") {
      obj.returnType = message.returnType;
    }
    if (message.identifier !== "") {
      obj.identifier = message.identifier;
    }
    if (message.parameterList?.length) {
      obj.parameterList = message.parameterList.map((e) => FunctionParameter.toJSON(e));
    }
    if (message.compoundStatement !== undefined) {
      obj.compoundStatement = CompoundStatement.toJSON(message.compoundStatement);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FunctionDefinition>, I>>(base?: I): FunctionDefinition {
    return FunctionDefinition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FunctionDefinition>, I>>(object: I): FunctionDefinition {
    const message = createBaseFunctionDefinition();
    message.id = object.id ?? "";
    message.returnType = object.returnType ?? "";
    message.identifier = object.identifier ?? "";
    message.parameterList = object.parameterList?.map((e) => FunctionParameter.fromPartial(e)) || [];
    message.compoundStatement = (object.compoundStatement !== undefined && object.compoundStatement !== null)
      ? CompoundStatement.fromPartial(object.compoundStatement)
      : undefined;
    return message;
  },
};

function createBaseFunctionParameter(): FunctionParameter {
  return { id: "", identifier: "", paramType: "" };
}

export const FunctionParameter: MessageFns<FunctionParameter> = {
  encode(message: FunctionParameter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.identifier !== "") {
      writer.uint32(18).string(message.identifier);
    }
    if (message.paramType !== "") {
      writer.uint32(26).string(message.paramType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunctionParameter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunctionParameter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.identifier = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.paramType = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunctionParameter {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      identifier: isSet(object.identifier) ? globalThis.String(object.identifier) : "",
      paramType: isSet(object.paramType) ? globalThis.String(object.paramType) : "",
    };
  },

  toJSON(message: FunctionParameter): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.identifier !== "") {
      obj.identifier = message.identifier;
    }
    if (message.paramType !== "") {
      obj.paramType = message.paramType;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FunctionParameter>, I>>(base?: I): FunctionParameter {
    return FunctionParameter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FunctionParameter>, I>>(object: I): FunctionParameter {
    const message = createBaseFunctionParameter();
    message.id = object.id ?? "";
    message.identifier = object.identifier ?? "";
    message.paramType = object.paramType ?? "";
    return message;
  },
};

function createBaseIfStatement(): IfStatement {
  return { id: "", condition: undefined, compoundStatement: undefined, elseClause: undefined };
}

export const IfStatement: MessageFns<IfStatement> = {
  encode(message: IfStatement, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.condition !== undefined) {
      LanguageObject.encode(message.condition, writer.uint32(18).fork()).join();
    }
    if (message.compoundStatement !== undefined) {
      CompoundStatement.encode(message.compoundStatement, writer.uint32(26).fork()).join();
    }
    if (message.elseClause !== undefined) {
      ElseClause.encode(message.elseClause, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IfStatement {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIfStatement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.condition = LanguageObject.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.compoundStatement = CompoundStatement.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.elseClause = ElseClause.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IfStatement {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      condition: isSet(object.condition) ? LanguageObject.fromJSON(object.condition) : undefined,
      compoundStatement: isSet(object.compoundStatement)
        ? CompoundStatement.fromJSON(object.compoundStatement)
        : undefined,
      elseClause: isSet(object.elseClause) ? ElseClause.fromJSON(object.elseClause) : undefined,
    };
  },

  toJSON(message: IfStatement): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.condition !== undefined) {
      obj.condition = LanguageObject.toJSON(message.condition);
    }
    if (message.compoundStatement !== undefined) {
      obj.compoundStatement = CompoundStatement.toJSON(message.compoundStatement);
    }
    if (message.elseClause !== undefined) {
      obj.elseClause = ElseClause.toJSON(message.elseClause);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IfStatement>, I>>(base?: I): IfStatement {
    return IfStatement.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IfStatement>, I>>(object: I): IfStatement {
    const message = createBaseIfStatement();
    message.id = object.id ?? "";
    message.condition = (object.condition !== undefined && object.condition !== null)
      ? LanguageObject.fromPartial(object.condition)
      : undefined;
    message.compoundStatement = (object.compoundStatement !== undefined && object.compoundStatement !== null)
      ? CompoundStatement.fromPartial(object.compoundStatement)
      : undefined;
    message.elseClause = (object.elseClause !== undefined && object.elseClause !== null)
      ? ElseClause.fromPartial(object.elseClause)
      : undefined;
    return message;
  },
};

function createBaseNumberLiteral(): NumberLiteral {
  return { id: "", value: "" };
}

export const NumberLiteral: MessageFns<NumberLiteral> = {
  encode(message: NumberLiteral, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NumberLiteral {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNumberLiteral();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NumberLiteral {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: NumberLiteral): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NumberLiteral>, I>>(base?: I): NumberLiteral {
    return NumberLiteral.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NumberLiteral>, I>>(object: I): NumberLiteral {
    const message = createBaseNumberLiteral();
    message.id = object.id ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBasePreprocInclude(): PreprocInclude {
  return { id: "", content: "" };
}

export const PreprocInclude: MessageFns<PreprocInclude> = {
  encode(message: PreprocInclude, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.content !== "") {
      writer.uint32(18).string(message.content);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PreprocInclude {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePreprocInclude();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.content = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PreprocInclude {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
    };
  },

  toJSON(message: PreprocInclude): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PreprocInclude>, I>>(base?: I): PreprocInclude {
    return PreprocInclude.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PreprocInclude>, I>>(object: I): PreprocInclude {
    const message = createBasePreprocInclude();
    message.id = object.id ?? "";
    message.content = object.content ?? "";
    return message;
  },
};

function createBaseReference(): Reference {
  return { id: "", declarationId: "", identifier: "" };
}

export const Reference: MessageFns<Reference> = {
  encode(message: Reference, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.declarationId !== "") {
      writer.uint32(18).string(message.declarationId);
    }
    if (message.identifier !== "") {
      writer.uint32(26).string(message.identifier);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Reference {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.declarationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.identifier = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Reference {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      declarationId: isSet(object.declarationId) ? globalThis.String(object.declarationId) : "",
      identifier: isSet(object.identifier) ? globalThis.String(object.identifier) : "",
    };
  },

  toJSON(message: Reference): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.declarationId !== "") {
      obj.declarationId = message.declarationId;
    }
    if (message.identifier !== "") {
      obj.identifier = message.identifier;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Reference>, I>>(base?: I): Reference {
    return Reference.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Reference>, I>>(object: I): Reference {
    const message = createBaseReference();
    message.id = object.id ?? "";
    message.declarationId = object.declarationId ?? "";
    message.identifier = object.identifier ?? "";
    return message;
  },
};

function createBaseReturnStatement(): ReturnStatement {
  return { id: "", value: undefined };
}

export const ReturnStatement: MessageFns<ReturnStatement> = {
  encode(message: ReturnStatement, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.value !== undefined) {
      LanguageObject.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReturnStatement {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReturnStatement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = LanguageObject.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReturnStatement {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      value: isSet(object.value) ? LanguageObject.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: ReturnStatement): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.value !== undefined) {
      obj.value = LanguageObject.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReturnStatement>, I>>(base?: I): ReturnStatement {
    return ReturnStatement.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReturnStatement>, I>>(object: I): ReturnStatement {
    const message = createBaseReturnStatement();
    message.id = object.id ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? LanguageObject.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseStringLiteral(): StringLiteral {
  return { id: "", value: "" };
}

export const StringLiteral: MessageFns<StringLiteral> = {
  encode(message: StringLiteral, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StringLiteral {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStringLiteral();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StringLiteral {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: StringLiteral): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StringLiteral>, I>>(base?: I): StringLiteral {
    return StringLiteral.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StringLiteral>, I>>(object: I): StringLiteral {
    const message = createBaseStringLiteral();
    message.id = object.id ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
