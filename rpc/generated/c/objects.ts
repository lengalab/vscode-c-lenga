// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v6.32.1
// source: c/objects.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "c.lenga";

export interface LanguageObject {
  languageObject?:
    | { $case: "sourceFile"; sourceFile: SourceFile }
    | { $case: "assignmentExpression"; assignmentExpression: AssignmentExpression }
    | { $case: "binaryExpression"; binaryExpression: BinaryExpression }
    | { $case: "callExpression"; callExpression: CallExpression }
    | { $case: "numberLiteral"; numberLiteral: NumberLiteral }
    | { $case: "reference"; reference: Reference }
    | { $case: "stringLiteral"; stringLiteral: StringLiteral }
    | { $case: "compoundStatement"; compoundStatement: CompoundStatement }
    | { $case: "ifStatement"; ifStatement: IfStatement }
    | { $case: "returnStatement"; returnStatement: ReturnStatement }
    | { $case: "declaration"; declaration: Declaration }
    | { $case: "functionDeclaration"; functionDeclaration: FunctionDeclaration }
    | { $case: "functionDefinition"; functionDefinition: FunctionDefinition }
    | { $case: "preprocInclude"; preprocInclude: PreprocInclude }
    | { $case: "comment"; comment: Comment }
    | { $case: "unknown"; unknown: Unknown }
    | { $case: "functionParameter"; functionParameter: FunctionParameter }
    | { $case: "elseClause"; elseClause: ElseClause }
    | undefined;
}

export interface DeclarationObject {
  declarationObject?:
    | { $case: "declaration"; declaration: Declaration }
    | { $case: "functionDeclaration"; functionDeclaration: FunctionDeclaration }
    | { $case: "functionDefinition"; functionDefinition: FunctionDefinition }
    | { $case: "preprocInclude"; preprocInclude: PreprocInclude }
    | { $case: "comment"; comment: Comment }
    | { $case: "unknown"; unknown: Unknown }
    | undefined;
}

export interface ExpressionObject {
  expressionObject?:
    | { $case: "assignmentExpression"; assignmentExpression: AssignmentExpression }
    | { $case: "binaryExpression"; binaryExpression: BinaryExpression }
    | { $case: "callExpression"; callExpression: CallExpression }
    | { $case: "numberLiteral"; numberLiteral: NumberLiteral }
    | { $case: "reference"; reference: Reference }
    | { $case: "stringLiteral"; stringLiteral: StringLiteral }
    | { $case: "unknown"; unknown: Unknown }
    | undefined;
}

export interface StatementObject {
  statementObject?:
    | { $case: "compoundStatement"; compoundStatement: CompoundStatement }
    | { $case: "ifStatement"; ifStatement: IfStatement }
    | { $case: "returnStatement"; returnStatement: ReturnStatement }
    | { $case: "unknown"; unknown: Unknown }
    | undefined;
}

export interface CompoundStatementObject {
  compoundStatementObject?:
    | { $case: "declaration"; declaration: Declaration }
    | { $case: "assignmentExpression"; assignmentExpression: AssignmentExpression }
    | { $case: "binaryExpression"; binaryExpression: BinaryExpression }
    | { $case: "callExpression"; callExpression: CallExpression }
    | { $case: "numberLiteral"; numberLiteral: NumberLiteral }
    | { $case: "reference"; reference: Reference }
    | { $case: "stringLiteral"; stringLiteral: StringLiteral }
    | { $case: "compoundStatement"; compoundStatement: CompoundStatement }
    | { $case: "ifStatement"; ifStatement: IfStatement }
    | { $case: "returnStatement"; returnStatement: ReturnStatement }
    | { $case: "comment"; comment: Comment }
    | { $case: "unknown"; unknown: Unknown }
    | undefined;
}

export interface SourceFile {
  id: string;
  code: DeclarationObject[];
}

export interface Unknown {
  id: string;
  content: string;
}

export interface AssignmentExpression {
  id: string;
  idDeclaration: string;
  identifier: string;
  value?: ExpressionObject | undefined;
}

export interface BinaryExpression {
  id: string;
  left?: ExpressionObject | undefined;
  operator: string;
  right?: ExpressionObject | undefined;
}

export interface CallExpression {
  id: string;
  idDeclaration: string;
  identifier: string;
  argumentList: ExpressionObject[];
}

export interface Comment {
  id: string;
  content: string;
}

export interface CompoundStatement {
  id: string;
  codeBlock: CompoundStatementObject[];
}

export interface Declaration {
  id: string;
  /** Assuming CType is serialized as string */
  primitiveType: string;
  identifier: string;
  value?: ExpressionObject | undefined;
}

export interface ElseClause {
  id: string;
  body?: CompoundStatementObject | undefined;
}

export interface FunctionDeclaration {
  id: string;
  /** CType serialized as string */
  returnType: string;
  identifier: string;
  parameterList: FunctionParameter[];
}

export interface FunctionDefinition {
  id: string;
  /** CType serialized as string */
  returnType: string;
  identifier: string;
  parameterList: FunctionParameter[];
  compoundStatement?: CompoundStatement | undefined;
}

export interface FunctionParameter {
  id: string;
  identifier: string;
  /** CType serialized as string */
  paramType: string;
}

export interface IfStatement {
  id: string;
  condition?: ExpressionObject | undefined;
  body?: CompoundStatementObject | undefined;
  elseStatement?:
    | { $case: "elseIf"; elseIf: IfStatement }
    | { $case: "elseClause"; elseClause: ElseClause }
    | undefined;
}

export interface NumberLiteral {
  id: string;
  value: string;
}

export interface PreprocInclude {
  id: string;
  content: string;
}

export interface Reference {
  id: string;
  declarationId: string;
  identifier: string;
}

export interface ReturnStatement {
  id: string;
  value?: ExpressionObject | undefined;
}

export interface StringLiteral {
  id: string;
  value: string;
}

function createBaseLanguageObject(): LanguageObject {
  return { languageObject: undefined };
}

export const LanguageObject: MessageFns<LanguageObject> = {
  encode(message: LanguageObject, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.languageObject?.$case) {
      case "sourceFile":
        SourceFile.encode(message.languageObject.sourceFile, writer.uint32(10).fork()).join();
        break;
      case "assignmentExpression":
        AssignmentExpression.encode(message.languageObject.assignmentExpression, writer.uint32(18).fork()).join();
        break;
      case "binaryExpression":
        BinaryExpression.encode(message.languageObject.binaryExpression, writer.uint32(26).fork()).join();
        break;
      case "callExpression":
        CallExpression.encode(message.languageObject.callExpression, writer.uint32(34).fork()).join();
        break;
      case "numberLiteral":
        NumberLiteral.encode(message.languageObject.numberLiteral, writer.uint32(42).fork()).join();
        break;
      case "reference":
        Reference.encode(message.languageObject.reference, writer.uint32(50).fork()).join();
        break;
      case "stringLiteral":
        StringLiteral.encode(message.languageObject.stringLiteral, writer.uint32(58).fork()).join();
        break;
      case "compoundStatement":
        CompoundStatement.encode(message.languageObject.compoundStatement, writer.uint32(66).fork()).join();
        break;
      case "ifStatement":
        IfStatement.encode(message.languageObject.ifStatement, writer.uint32(74).fork()).join();
        break;
      case "returnStatement":
        ReturnStatement.encode(message.languageObject.returnStatement, writer.uint32(82).fork()).join();
        break;
      case "declaration":
        Declaration.encode(message.languageObject.declaration, writer.uint32(90).fork()).join();
        break;
      case "functionDeclaration":
        FunctionDeclaration.encode(message.languageObject.functionDeclaration, writer.uint32(98).fork()).join();
        break;
      case "functionDefinition":
        FunctionDefinition.encode(message.languageObject.functionDefinition, writer.uint32(106).fork()).join();
        break;
      case "preprocInclude":
        PreprocInclude.encode(message.languageObject.preprocInclude, writer.uint32(114).fork()).join();
        break;
      case "comment":
        Comment.encode(message.languageObject.comment, writer.uint32(122).fork()).join();
        break;
      case "unknown":
        Unknown.encode(message.languageObject.unknown, writer.uint32(3234).fork()).join();
        break;
      case "functionParameter":
        FunctionParameter.encode(message.languageObject.functionParameter, writer.uint32(130).fork()).join();
        break;
      case "elseClause":
        ElseClause.encode(message.languageObject.elseClause, writer.uint32(138).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LanguageObject {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLanguageObject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.languageObject = { $case: "sourceFile", sourceFile: SourceFile.decode(reader, reader.uint32()) };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.languageObject = {
            $case: "assignmentExpression",
            assignmentExpression: AssignmentExpression.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.languageObject = {
            $case: "binaryExpression",
            binaryExpression: BinaryExpression.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.languageObject = {
            $case: "callExpression",
            callExpression: CallExpression.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.languageObject = {
            $case: "numberLiteral",
            numberLiteral: NumberLiteral.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.languageObject = { $case: "reference", reference: Reference.decode(reader, reader.uint32()) };
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.languageObject = {
            $case: "stringLiteral",
            stringLiteral: StringLiteral.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.languageObject = {
            $case: "compoundStatement",
            compoundStatement: CompoundStatement.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.languageObject = { $case: "ifStatement", ifStatement: IfStatement.decode(reader, reader.uint32()) };
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.languageObject = {
            $case: "returnStatement",
            returnStatement: ReturnStatement.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.languageObject = { $case: "declaration", declaration: Declaration.decode(reader, reader.uint32()) };
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.languageObject = {
            $case: "functionDeclaration",
            functionDeclaration: FunctionDeclaration.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.languageObject = {
            $case: "functionDefinition",
            functionDefinition: FunctionDefinition.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.languageObject = {
            $case: "preprocInclude",
            preprocInclude: PreprocInclude.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.languageObject = { $case: "comment", comment: Comment.decode(reader, reader.uint32()) };
          continue;
        }
        case 404: {
          if (tag !== 3234) {
            break;
          }

          message.languageObject = { $case: "unknown", unknown: Unknown.decode(reader, reader.uint32()) };
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.languageObject = {
            $case: "functionParameter",
            functionParameter: FunctionParameter.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.languageObject = { $case: "elseClause", elseClause: ElseClause.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LanguageObject {
    return {
      languageObject: isSet(object.sourceFile)
        ? { $case: "sourceFile", sourceFile: SourceFile.fromJSON(object.sourceFile) }
        : isSet(object.assignmentExpression)
        ? {
          $case: "assignmentExpression",
          assignmentExpression: AssignmentExpression.fromJSON(object.assignmentExpression),
        }
        : isSet(object.binaryExpression)
        ? { $case: "binaryExpression", binaryExpression: BinaryExpression.fromJSON(object.binaryExpression) }
        : isSet(object.callExpression)
        ? { $case: "callExpression", callExpression: CallExpression.fromJSON(object.callExpression) }
        : isSet(object.numberLiteral)
        ? { $case: "numberLiteral", numberLiteral: NumberLiteral.fromJSON(object.numberLiteral) }
        : isSet(object.reference)
        ? { $case: "reference", reference: Reference.fromJSON(object.reference) }
        : isSet(object.stringLiteral)
        ? { $case: "stringLiteral", stringLiteral: StringLiteral.fromJSON(object.stringLiteral) }
        : isSet(object.compoundStatement)
        ? { $case: "compoundStatement", compoundStatement: CompoundStatement.fromJSON(object.compoundStatement) }
        : isSet(object.ifStatement)
        ? { $case: "ifStatement", ifStatement: IfStatement.fromJSON(object.ifStatement) }
        : isSet(object.returnStatement)
        ? { $case: "returnStatement", returnStatement: ReturnStatement.fromJSON(object.returnStatement) }
        : isSet(object.declaration)
        ? { $case: "declaration", declaration: Declaration.fromJSON(object.declaration) }
        : isSet(object.functionDeclaration)
        ? {
          $case: "functionDeclaration",
          functionDeclaration: FunctionDeclaration.fromJSON(object.functionDeclaration),
        }
        : isSet(object.functionDefinition)
        ? { $case: "functionDefinition", functionDefinition: FunctionDefinition.fromJSON(object.functionDefinition) }
        : isSet(object.preprocInclude)
        ? { $case: "preprocInclude", preprocInclude: PreprocInclude.fromJSON(object.preprocInclude) }
        : isSet(object.comment)
        ? { $case: "comment", comment: Comment.fromJSON(object.comment) }
        : isSet(object.unknown)
        ? { $case: "unknown", unknown: Unknown.fromJSON(object.unknown) }
        : isSet(object.functionParameter)
        ? { $case: "functionParameter", functionParameter: FunctionParameter.fromJSON(object.functionParameter) }
        : isSet(object.elseClause)
        ? { $case: "elseClause", elseClause: ElseClause.fromJSON(object.elseClause) }
        : undefined,
    };
  },

  toJSON(message: LanguageObject): unknown {
    const obj: any = {};
    if (message.languageObject?.$case === "sourceFile") {
      obj.sourceFile = SourceFile.toJSON(message.languageObject.sourceFile);
    } else if (message.languageObject?.$case === "assignmentExpression") {
      obj.assignmentExpression = AssignmentExpression.toJSON(message.languageObject.assignmentExpression);
    } else if (message.languageObject?.$case === "binaryExpression") {
      obj.binaryExpression = BinaryExpression.toJSON(message.languageObject.binaryExpression);
    } else if (message.languageObject?.$case === "callExpression") {
      obj.callExpression = CallExpression.toJSON(message.languageObject.callExpression);
    } else if (message.languageObject?.$case === "numberLiteral") {
      obj.numberLiteral = NumberLiteral.toJSON(message.languageObject.numberLiteral);
    } else if (message.languageObject?.$case === "reference") {
      obj.reference = Reference.toJSON(message.languageObject.reference);
    } else if (message.languageObject?.$case === "stringLiteral") {
      obj.stringLiteral = StringLiteral.toJSON(message.languageObject.stringLiteral);
    } else if (message.languageObject?.$case === "compoundStatement") {
      obj.compoundStatement = CompoundStatement.toJSON(message.languageObject.compoundStatement);
    } else if (message.languageObject?.$case === "ifStatement") {
      obj.ifStatement = IfStatement.toJSON(message.languageObject.ifStatement);
    } else if (message.languageObject?.$case === "returnStatement") {
      obj.returnStatement = ReturnStatement.toJSON(message.languageObject.returnStatement);
    } else if (message.languageObject?.$case === "declaration") {
      obj.declaration = Declaration.toJSON(message.languageObject.declaration);
    } else if (message.languageObject?.$case === "functionDeclaration") {
      obj.functionDeclaration = FunctionDeclaration.toJSON(message.languageObject.functionDeclaration);
    } else if (message.languageObject?.$case === "functionDefinition") {
      obj.functionDefinition = FunctionDefinition.toJSON(message.languageObject.functionDefinition);
    } else if (message.languageObject?.$case === "preprocInclude") {
      obj.preprocInclude = PreprocInclude.toJSON(message.languageObject.preprocInclude);
    } else if (message.languageObject?.$case === "comment") {
      obj.comment = Comment.toJSON(message.languageObject.comment);
    } else if (message.languageObject?.$case === "unknown") {
      obj.unknown = Unknown.toJSON(message.languageObject.unknown);
    } else if (message.languageObject?.$case === "functionParameter") {
      obj.functionParameter = FunctionParameter.toJSON(message.languageObject.functionParameter);
    } else if (message.languageObject?.$case === "elseClause") {
      obj.elseClause = ElseClause.toJSON(message.languageObject.elseClause);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LanguageObject>, I>>(base?: I): LanguageObject {
    return LanguageObject.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LanguageObject>, I>>(object: I): LanguageObject {
    const message = createBaseLanguageObject();
    switch (object.languageObject?.$case) {
      case "sourceFile": {
        if (object.languageObject?.sourceFile !== undefined && object.languageObject?.sourceFile !== null) {
          message.languageObject = {
            $case: "sourceFile",
            sourceFile: SourceFile.fromPartial(object.languageObject.sourceFile),
          };
        }
        break;
      }
      case "assignmentExpression": {
        if (
          object.languageObject?.assignmentExpression !== undefined &&
          object.languageObject?.assignmentExpression !== null
        ) {
          message.languageObject = {
            $case: "assignmentExpression",
            assignmentExpression: AssignmentExpression.fromPartial(object.languageObject.assignmentExpression),
          };
        }
        break;
      }
      case "binaryExpression": {
        if (object.languageObject?.binaryExpression !== undefined && object.languageObject?.binaryExpression !== null) {
          message.languageObject = {
            $case: "binaryExpression",
            binaryExpression: BinaryExpression.fromPartial(object.languageObject.binaryExpression),
          };
        }
        break;
      }
      case "callExpression": {
        if (object.languageObject?.callExpression !== undefined && object.languageObject?.callExpression !== null) {
          message.languageObject = {
            $case: "callExpression",
            callExpression: CallExpression.fromPartial(object.languageObject.callExpression),
          };
        }
        break;
      }
      case "numberLiteral": {
        if (object.languageObject?.numberLiteral !== undefined && object.languageObject?.numberLiteral !== null) {
          message.languageObject = {
            $case: "numberLiteral",
            numberLiteral: NumberLiteral.fromPartial(object.languageObject.numberLiteral),
          };
        }
        break;
      }
      case "reference": {
        if (object.languageObject?.reference !== undefined && object.languageObject?.reference !== null) {
          message.languageObject = {
            $case: "reference",
            reference: Reference.fromPartial(object.languageObject.reference),
          };
        }
        break;
      }
      case "stringLiteral": {
        if (object.languageObject?.stringLiteral !== undefined && object.languageObject?.stringLiteral !== null) {
          message.languageObject = {
            $case: "stringLiteral",
            stringLiteral: StringLiteral.fromPartial(object.languageObject.stringLiteral),
          };
        }
        break;
      }
      case "compoundStatement": {
        if (
          object.languageObject?.compoundStatement !== undefined && object.languageObject?.compoundStatement !== null
        ) {
          message.languageObject = {
            $case: "compoundStatement",
            compoundStatement: CompoundStatement.fromPartial(object.languageObject.compoundStatement),
          };
        }
        break;
      }
      case "ifStatement": {
        if (object.languageObject?.ifStatement !== undefined && object.languageObject?.ifStatement !== null) {
          message.languageObject = {
            $case: "ifStatement",
            ifStatement: IfStatement.fromPartial(object.languageObject.ifStatement),
          };
        }
        break;
      }
      case "returnStatement": {
        if (object.languageObject?.returnStatement !== undefined && object.languageObject?.returnStatement !== null) {
          message.languageObject = {
            $case: "returnStatement",
            returnStatement: ReturnStatement.fromPartial(object.languageObject.returnStatement),
          };
        }
        break;
      }
      case "declaration": {
        if (object.languageObject?.declaration !== undefined && object.languageObject?.declaration !== null) {
          message.languageObject = {
            $case: "declaration",
            declaration: Declaration.fromPartial(object.languageObject.declaration),
          };
        }
        break;
      }
      case "functionDeclaration": {
        if (
          object.languageObject?.functionDeclaration !== undefined &&
          object.languageObject?.functionDeclaration !== null
        ) {
          message.languageObject = {
            $case: "functionDeclaration",
            functionDeclaration: FunctionDeclaration.fromPartial(object.languageObject.functionDeclaration),
          };
        }
        break;
      }
      case "functionDefinition": {
        if (
          object.languageObject?.functionDefinition !== undefined && object.languageObject?.functionDefinition !== null
        ) {
          message.languageObject = {
            $case: "functionDefinition",
            functionDefinition: FunctionDefinition.fromPartial(object.languageObject.functionDefinition),
          };
        }
        break;
      }
      case "preprocInclude": {
        if (object.languageObject?.preprocInclude !== undefined && object.languageObject?.preprocInclude !== null) {
          message.languageObject = {
            $case: "preprocInclude",
            preprocInclude: PreprocInclude.fromPartial(object.languageObject.preprocInclude),
          };
        }
        break;
      }
      case "comment": {
        if (object.languageObject?.comment !== undefined && object.languageObject?.comment !== null) {
          message.languageObject = { $case: "comment", comment: Comment.fromPartial(object.languageObject.comment) };
        }
        break;
      }
      case "unknown": {
        if (object.languageObject?.unknown !== undefined && object.languageObject?.unknown !== null) {
          message.languageObject = { $case: "unknown", unknown: Unknown.fromPartial(object.languageObject.unknown) };
        }
        break;
      }
      case "functionParameter": {
        if (
          object.languageObject?.functionParameter !== undefined && object.languageObject?.functionParameter !== null
        ) {
          message.languageObject = {
            $case: "functionParameter",
            functionParameter: FunctionParameter.fromPartial(object.languageObject.functionParameter),
          };
        }
        break;
      }
      case "elseClause": {
        if (object.languageObject?.elseClause !== undefined && object.languageObject?.elseClause !== null) {
          message.languageObject = {
            $case: "elseClause",
            elseClause: ElseClause.fromPartial(object.languageObject.elseClause),
          };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseDeclarationObject(): DeclarationObject {
  return { declarationObject: undefined };
}

export const DeclarationObject: MessageFns<DeclarationObject> = {
  encode(message: DeclarationObject, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.declarationObject?.$case) {
      case "declaration":
        Declaration.encode(message.declarationObject.declaration, writer.uint32(10).fork()).join();
        break;
      case "functionDeclaration":
        FunctionDeclaration.encode(message.declarationObject.functionDeclaration, writer.uint32(18).fork()).join();
        break;
      case "functionDefinition":
        FunctionDefinition.encode(message.declarationObject.functionDefinition, writer.uint32(26).fork()).join();
        break;
      case "preprocInclude":
        PreprocInclude.encode(message.declarationObject.preprocInclude, writer.uint32(34).fork()).join();
        break;
      case "comment":
        Comment.encode(message.declarationObject.comment, writer.uint32(42).fork()).join();
        break;
      case "unknown":
        Unknown.encode(message.declarationObject.unknown, writer.uint32(50).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeclarationObject {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeclarationObject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.declarationObject = {
            $case: "declaration",
            declaration: Declaration.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.declarationObject = {
            $case: "functionDeclaration",
            functionDeclaration: FunctionDeclaration.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.declarationObject = {
            $case: "functionDefinition",
            functionDefinition: FunctionDefinition.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.declarationObject = {
            $case: "preprocInclude",
            preprocInclude: PreprocInclude.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.declarationObject = { $case: "comment", comment: Comment.decode(reader, reader.uint32()) };
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.declarationObject = { $case: "unknown", unknown: Unknown.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeclarationObject {
    return {
      declarationObject: isSet(object.declaration)
        ? { $case: "declaration", declaration: Declaration.fromJSON(object.declaration) }
        : isSet(object.functionDeclaration)
        ? {
          $case: "functionDeclaration",
          functionDeclaration: FunctionDeclaration.fromJSON(object.functionDeclaration),
        }
        : isSet(object.functionDefinition)
        ? { $case: "functionDefinition", functionDefinition: FunctionDefinition.fromJSON(object.functionDefinition) }
        : isSet(object.preprocInclude)
        ? { $case: "preprocInclude", preprocInclude: PreprocInclude.fromJSON(object.preprocInclude) }
        : isSet(object.comment)
        ? { $case: "comment", comment: Comment.fromJSON(object.comment) }
        : isSet(object.unknown)
        ? { $case: "unknown", unknown: Unknown.fromJSON(object.unknown) }
        : undefined,
    };
  },

  toJSON(message: DeclarationObject): unknown {
    const obj: any = {};
    if (message.declarationObject?.$case === "declaration") {
      obj.declaration = Declaration.toJSON(message.declarationObject.declaration);
    } else if (message.declarationObject?.$case === "functionDeclaration") {
      obj.functionDeclaration = FunctionDeclaration.toJSON(message.declarationObject.functionDeclaration);
    } else if (message.declarationObject?.$case === "functionDefinition") {
      obj.functionDefinition = FunctionDefinition.toJSON(message.declarationObject.functionDefinition);
    } else if (message.declarationObject?.$case === "preprocInclude") {
      obj.preprocInclude = PreprocInclude.toJSON(message.declarationObject.preprocInclude);
    } else if (message.declarationObject?.$case === "comment") {
      obj.comment = Comment.toJSON(message.declarationObject.comment);
    } else if (message.declarationObject?.$case === "unknown") {
      obj.unknown = Unknown.toJSON(message.declarationObject.unknown);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeclarationObject>, I>>(base?: I): DeclarationObject {
    return DeclarationObject.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeclarationObject>, I>>(object: I): DeclarationObject {
    const message = createBaseDeclarationObject();
    switch (object.declarationObject?.$case) {
      case "declaration": {
        if (object.declarationObject?.declaration !== undefined && object.declarationObject?.declaration !== null) {
          message.declarationObject = {
            $case: "declaration",
            declaration: Declaration.fromPartial(object.declarationObject.declaration),
          };
        }
        break;
      }
      case "functionDeclaration": {
        if (
          object.declarationObject?.functionDeclaration !== undefined &&
          object.declarationObject?.functionDeclaration !== null
        ) {
          message.declarationObject = {
            $case: "functionDeclaration",
            functionDeclaration: FunctionDeclaration.fromPartial(object.declarationObject.functionDeclaration),
          };
        }
        break;
      }
      case "functionDefinition": {
        if (
          object.declarationObject?.functionDefinition !== undefined &&
          object.declarationObject?.functionDefinition !== null
        ) {
          message.declarationObject = {
            $case: "functionDefinition",
            functionDefinition: FunctionDefinition.fromPartial(object.declarationObject.functionDefinition),
          };
        }
        break;
      }
      case "preprocInclude": {
        if (
          object.declarationObject?.preprocInclude !== undefined && object.declarationObject?.preprocInclude !== null
        ) {
          message.declarationObject = {
            $case: "preprocInclude",
            preprocInclude: PreprocInclude.fromPartial(object.declarationObject.preprocInclude),
          };
        }
        break;
      }
      case "comment": {
        if (object.declarationObject?.comment !== undefined && object.declarationObject?.comment !== null) {
          message.declarationObject = {
            $case: "comment",
            comment: Comment.fromPartial(object.declarationObject.comment),
          };
        }
        break;
      }
      case "unknown": {
        if (object.declarationObject?.unknown !== undefined && object.declarationObject?.unknown !== null) {
          message.declarationObject = {
            $case: "unknown",
            unknown: Unknown.fromPartial(object.declarationObject.unknown),
          };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseExpressionObject(): ExpressionObject {
  return { expressionObject: undefined };
}

export const ExpressionObject: MessageFns<ExpressionObject> = {
  encode(message: ExpressionObject, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.expressionObject?.$case) {
      case "assignmentExpression":
        AssignmentExpression.encode(message.expressionObject.assignmentExpression, writer.uint32(10).fork()).join();
        break;
      case "binaryExpression":
        BinaryExpression.encode(message.expressionObject.binaryExpression, writer.uint32(18).fork()).join();
        break;
      case "callExpression":
        CallExpression.encode(message.expressionObject.callExpression, writer.uint32(26).fork()).join();
        break;
      case "numberLiteral":
        NumberLiteral.encode(message.expressionObject.numberLiteral, writer.uint32(34).fork()).join();
        break;
      case "reference":
        Reference.encode(message.expressionObject.reference, writer.uint32(42).fork()).join();
        break;
      case "stringLiteral":
        StringLiteral.encode(message.expressionObject.stringLiteral, writer.uint32(50).fork()).join();
        break;
      case "unknown":
        Unknown.encode(message.expressionObject.unknown, writer.uint32(58).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExpressionObject {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExpressionObject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.expressionObject = {
            $case: "assignmentExpression",
            assignmentExpression: AssignmentExpression.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.expressionObject = {
            $case: "binaryExpression",
            binaryExpression: BinaryExpression.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.expressionObject = {
            $case: "callExpression",
            callExpression: CallExpression.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.expressionObject = {
            $case: "numberLiteral",
            numberLiteral: NumberLiteral.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.expressionObject = { $case: "reference", reference: Reference.decode(reader, reader.uint32()) };
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.expressionObject = {
            $case: "stringLiteral",
            stringLiteral: StringLiteral.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.expressionObject = { $case: "unknown", unknown: Unknown.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExpressionObject {
    return {
      expressionObject: isSet(object.assignmentExpression)
        ? {
          $case: "assignmentExpression",
          assignmentExpression: AssignmentExpression.fromJSON(object.assignmentExpression),
        }
        : isSet(object.binaryExpression)
        ? { $case: "binaryExpression", binaryExpression: BinaryExpression.fromJSON(object.binaryExpression) }
        : isSet(object.callExpression)
        ? { $case: "callExpression", callExpression: CallExpression.fromJSON(object.callExpression) }
        : isSet(object.numberLiteral)
        ? { $case: "numberLiteral", numberLiteral: NumberLiteral.fromJSON(object.numberLiteral) }
        : isSet(object.reference)
        ? { $case: "reference", reference: Reference.fromJSON(object.reference) }
        : isSet(object.stringLiteral)
        ? { $case: "stringLiteral", stringLiteral: StringLiteral.fromJSON(object.stringLiteral) }
        : isSet(object.unknown)
        ? { $case: "unknown", unknown: Unknown.fromJSON(object.unknown) }
        : undefined,
    };
  },

  toJSON(message: ExpressionObject): unknown {
    const obj: any = {};
    if (message.expressionObject?.$case === "assignmentExpression") {
      obj.assignmentExpression = AssignmentExpression.toJSON(message.expressionObject.assignmentExpression);
    } else if (message.expressionObject?.$case === "binaryExpression") {
      obj.binaryExpression = BinaryExpression.toJSON(message.expressionObject.binaryExpression);
    } else if (message.expressionObject?.$case === "callExpression") {
      obj.callExpression = CallExpression.toJSON(message.expressionObject.callExpression);
    } else if (message.expressionObject?.$case === "numberLiteral") {
      obj.numberLiteral = NumberLiteral.toJSON(message.expressionObject.numberLiteral);
    } else if (message.expressionObject?.$case === "reference") {
      obj.reference = Reference.toJSON(message.expressionObject.reference);
    } else if (message.expressionObject?.$case === "stringLiteral") {
      obj.stringLiteral = StringLiteral.toJSON(message.expressionObject.stringLiteral);
    } else if (message.expressionObject?.$case === "unknown") {
      obj.unknown = Unknown.toJSON(message.expressionObject.unknown);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExpressionObject>, I>>(base?: I): ExpressionObject {
    return ExpressionObject.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExpressionObject>, I>>(object: I): ExpressionObject {
    const message = createBaseExpressionObject();
    switch (object.expressionObject?.$case) {
      case "assignmentExpression": {
        if (
          object.expressionObject?.assignmentExpression !== undefined &&
          object.expressionObject?.assignmentExpression !== null
        ) {
          message.expressionObject = {
            $case: "assignmentExpression",
            assignmentExpression: AssignmentExpression.fromPartial(object.expressionObject.assignmentExpression),
          };
        }
        break;
      }
      case "binaryExpression": {
        if (
          object.expressionObject?.binaryExpression !== undefined && object.expressionObject?.binaryExpression !== null
        ) {
          message.expressionObject = {
            $case: "binaryExpression",
            binaryExpression: BinaryExpression.fromPartial(object.expressionObject.binaryExpression),
          };
        }
        break;
      }
      case "callExpression": {
        if (object.expressionObject?.callExpression !== undefined && object.expressionObject?.callExpression !== null) {
          message.expressionObject = {
            $case: "callExpression",
            callExpression: CallExpression.fromPartial(object.expressionObject.callExpression),
          };
        }
        break;
      }
      case "numberLiteral": {
        if (object.expressionObject?.numberLiteral !== undefined && object.expressionObject?.numberLiteral !== null) {
          message.expressionObject = {
            $case: "numberLiteral",
            numberLiteral: NumberLiteral.fromPartial(object.expressionObject.numberLiteral),
          };
        }
        break;
      }
      case "reference": {
        if (object.expressionObject?.reference !== undefined && object.expressionObject?.reference !== null) {
          message.expressionObject = {
            $case: "reference",
            reference: Reference.fromPartial(object.expressionObject.reference),
          };
        }
        break;
      }
      case "stringLiteral": {
        if (object.expressionObject?.stringLiteral !== undefined && object.expressionObject?.stringLiteral !== null) {
          message.expressionObject = {
            $case: "stringLiteral",
            stringLiteral: StringLiteral.fromPartial(object.expressionObject.stringLiteral),
          };
        }
        break;
      }
      case "unknown": {
        if (object.expressionObject?.unknown !== undefined && object.expressionObject?.unknown !== null) {
          message.expressionObject = {
            $case: "unknown",
            unknown: Unknown.fromPartial(object.expressionObject.unknown),
          };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseStatementObject(): StatementObject {
  return { statementObject: undefined };
}

export const StatementObject: MessageFns<StatementObject> = {
  encode(message: StatementObject, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.statementObject?.$case) {
      case "compoundStatement":
        CompoundStatement.encode(message.statementObject.compoundStatement, writer.uint32(10).fork()).join();
        break;
      case "ifStatement":
        IfStatement.encode(message.statementObject.ifStatement, writer.uint32(18).fork()).join();
        break;
      case "returnStatement":
        ReturnStatement.encode(message.statementObject.returnStatement, writer.uint32(26).fork()).join();
        break;
      case "unknown":
        Unknown.encode(message.statementObject.unknown, writer.uint32(34).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StatementObject {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatementObject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.statementObject = {
            $case: "compoundStatement",
            compoundStatement: CompoundStatement.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.statementObject = { $case: "ifStatement", ifStatement: IfStatement.decode(reader, reader.uint32()) };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.statementObject = {
            $case: "returnStatement",
            returnStatement: ReturnStatement.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.statementObject = { $case: "unknown", unknown: Unknown.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StatementObject {
    return {
      statementObject: isSet(object.compoundStatement)
        ? { $case: "compoundStatement", compoundStatement: CompoundStatement.fromJSON(object.compoundStatement) }
        : isSet(object.ifStatement)
        ? { $case: "ifStatement", ifStatement: IfStatement.fromJSON(object.ifStatement) }
        : isSet(object.returnStatement)
        ? { $case: "returnStatement", returnStatement: ReturnStatement.fromJSON(object.returnStatement) }
        : isSet(object.unknown)
        ? { $case: "unknown", unknown: Unknown.fromJSON(object.unknown) }
        : undefined,
    };
  },

  toJSON(message: StatementObject): unknown {
    const obj: any = {};
    if (message.statementObject?.$case === "compoundStatement") {
      obj.compoundStatement = CompoundStatement.toJSON(message.statementObject.compoundStatement);
    } else if (message.statementObject?.$case === "ifStatement") {
      obj.ifStatement = IfStatement.toJSON(message.statementObject.ifStatement);
    } else if (message.statementObject?.$case === "returnStatement") {
      obj.returnStatement = ReturnStatement.toJSON(message.statementObject.returnStatement);
    } else if (message.statementObject?.$case === "unknown") {
      obj.unknown = Unknown.toJSON(message.statementObject.unknown);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StatementObject>, I>>(base?: I): StatementObject {
    return StatementObject.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StatementObject>, I>>(object: I): StatementObject {
    const message = createBaseStatementObject();
    switch (object.statementObject?.$case) {
      case "compoundStatement": {
        if (
          object.statementObject?.compoundStatement !== undefined && object.statementObject?.compoundStatement !== null
        ) {
          message.statementObject = {
            $case: "compoundStatement",
            compoundStatement: CompoundStatement.fromPartial(object.statementObject.compoundStatement),
          };
        }
        break;
      }
      case "ifStatement": {
        if (object.statementObject?.ifStatement !== undefined && object.statementObject?.ifStatement !== null) {
          message.statementObject = {
            $case: "ifStatement",
            ifStatement: IfStatement.fromPartial(object.statementObject.ifStatement),
          };
        }
        break;
      }
      case "returnStatement": {
        if (object.statementObject?.returnStatement !== undefined && object.statementObject?.returnStatement !== null) {
          message.statementObject = {
            $case: "returnStatement",
            returnStatement: ReturnStatement.fromPartial(object.statementObject.returnStatement),
          };
        }
        break;
      }
      case "unknown": {
        if (object.statementObject?.unknown !== undefined && object.statementObject?.unknown !== null) {
          message.statementObject = { $case: "unknown", unknown: Unknown.fromPartial(object.statementObject.unknown) };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseCompoundStatementObject(): CompoundStatementObject {
  return { compoundStatementObject: undefined };
}

export const CompoundStatementObject: MessageFns<CompoundStatementObject> = {
  encode(message: CompoundStatementObject, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.compoundStatementObject?.$case) {
      case "declaration":
        Declaration.encode(message.compoundStatementObject.declaration, writer.uint32(10).fork()).join();
        break;
      case "assignmentExpression":
        AssignmentExpression.encode(message.compoundStatementObject.assignmentExpression, writer.uint32(18).fork())
          .join();
        break;
      case "binaryExpression":
        BinaryExpression.encode(message.compoundStatementObject.binaryExpression, writer.uint32(26).fork()).join();
        break;
      case "callExpression":
        CallExpression.encode(message.compoundStatementObject.callExpression, writer.uint32(34).fork()).join();
        break;
      case "numberLiteral":
        NumberLiteral.encode(message.compoundStatementObject.numberLiteral, writer.uint32(42).fork()).join();
        break;
      case "reference":
        Reference.encode(message.compoundStatementObject.reference, writer.uint32(50).fork()).join();
        break;
      case "stringLiteral":
        StringLiteral.encode(message.compoundStatementObject.stringLiteral, writer.uint32(58).fork()).join();
        break;
      case "compoundStatement":
        CompoundStatement.encode(message.compoundStatementObject.compoundStatement, writer.uint32(66).fork()).join();
        break;
      case "ifStatement":
        IfStatement.encode(message.compoundStatementObject.ifStatement, writer.uint32(74).fork()).join();
        break;
      case "returnStatement":
        ReturnStatement.encode(message.compoundStatementObject.returnStatement, writer.uint32(82).fork()).join();
        break;
      case "comment":
        Comment.encode(message.compoundStatementObject.comment, writer.uint32(90).fork()).join();
        break;
      case "unknown":
        Unknown.encode(message.compoundStatementObject.unknown, writer.uint32(98).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CompoundStatementObject {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompoundStatementObject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.compoundStatementObject = {
            $case: "declaration",
            declaration: Declaration.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.compoundStatementObject = {
            $case: "assignmentExpression",
            assignmentExpression: AssignmentExpression.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.compoundStatementObject = {
            $case: "binaryExpression",
            binaryExpression: BinaryExpression.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.compoundStatementObject = {
            $case: "callExpression",
            callExpression: CallExpression.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.compoundStatementObject = {
            $case: "numberLiteral",
            numberLiteral: NumberLiteral.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.compoundStatementObject = {
            $case: "reference",
            reference: Reference.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.compoundStatementObject = {
            $case: "stringLiteral",
            stringLiteral: StringLiteral.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.compoundStatementObject = {
            $case: "compoundStatement",
            compoundStatement: CompoundStatement.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.compoundStatementObject = {
            $case: "ifStatement",
            ifStatement: IfStatement.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.compoundStatementObject = {
            $case: "returnStatement",
            returnStatement: ReturnStatement.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.compoundStatementObject = { $case: "comment", comment: Comment.decode(reader, reader.uint32()) };
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.compoundStatementObject = { $case: "unknown", unknown: Unknown.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CompoundStatementObject {
    return {
      compoundStatementObject: isSet(object.declaration)
        ? { $case: "declaration", declaration: Declaration.fromJSON(object.declaration) }
        : isSet(object.assignmentExpression)
        ? {
          $case: "assignmentExpression",
          assignmentExpression: AssignmentExpression.fromJSON(object.assignmentExpression),
        }
        : isSet(object.binaryExpression)
        ? { $case: "binaryExpression", binaryExpression: BinaryExpression.fromJSON(object.binaryExpression) }
        : isSet(object.callExpression)
        ? { $case: "callExpression", callExpression: CallExpression.fromJSON(object.callExpression) }
        : isSet(object.numberLiteral)
        ? { $case: "numberLiteral", numberLiteral: NumberLiteral.fromJSON(object.numberLiteral) }
        : isSet(object.reference)
        ? { $case: "reference", reference: Reference.fromJSON(object.reference) }
        : isSet(object.stringLiteral)
        ? { $case: "stringLiteral", stringLiteral: StringLiteral.fromJSON(object.stringLiteral) }
        : isSet(object.compoundStatement)
        ? { $case: "compoundStatement", compoundStatement: CompoundStatement.fromJSON(object.compoundStatement) }
        : isSet(object.ifStatement)
        ? { $case: "ifStatement", ifStatement: IfStatement.fromJSON(object.ifStatement) }
        : isSet(object.returnStatement)
        ? { $case: "returnStatement", returnStatement: ReturnStatement.fromJSON(object.returnStatement) }
        : isSet(object.comment)
        ? { $case: "comment", comment: Comment.fromJSON(object.comment) }
        : isSet(object.unknown)
        ? { $case: "unknown", unknown: Unknown.fromJSON(object.unknown) }
        : undefined,
    };
  },

  toJSON(message: CompoundStatementObject): unknown {
    const obj: any = {};
    if (message.compoundStatementObject?.$case === "declaration") {
      obj.declaration = Declaration.toJSON(message.compoundStatementObject.declaration);
    } else if (message.compoundStatementObject?.$case === "assignmentExpression") {
      obj.assignmentExpression = AssignmentExpression.toJSON(message.compoundStatementObject.assignmentExpression);
    } else if (message.compoundStatementObject?.$case === "binaryExpression") {
      obj.binaryExpression = BinaryExpression.toJSON(message.compoundStatementObject.binaryExpression);
    } else if (message.compoundStatementObject?.$case === "callExpression") {
      obj.callExpression = CallExpression.toJSON(message.compoundStatementObject.callExpression);
    } else if (message.compoundStatementObject?.$case === "numberLiteral") {
      obj.numberLiteral = NumberLiteral.toJSON(message.compoundStatementObject.numberLiteral);
    } else if (message.compoundStatementObject?.$case === "reference") {
      obj.reference = Reference.toJSON(message.compoundStatementObject.reference);
    } else if (message.compoundStatementObject?.$case === "stringLiteral") {
      obj.stringLiteral = StringLiteral.toJSON(message.compoundStatementObject.stringLiteral);
    } else if (message.compoundStatementObject?.$case === "compoundStatement") {
      obj.compoundStatement = CompoundStatement.toJSON(message.compoundStatementObject.compoundStatement);
    } else if (message.compoundStatementObject?.$case === "ifStatement") {
      obj.ifStatement = IfStatement.toJSON(message.compoundStatementObject.ifStatement);
    } else if (message.compoundStatementObject?.$case === "returnStatement") {
      obj.returnStatement = ReturnStatement.toJSON(message.compoundStatementObject.returnStatement);
    } else if (message.compoundStatementObject?.$case === "comment") {
      obj.comment = Comment.toJSON(message.compoundStatementObject.comment);
    } else if (message.compoundStatementObject?.$case === "unknown") {
      obj.unknown = Unknown.toJSON(message.compoundStatementObject.unknown);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CompoundStatementObject>, I>>(base?: I): CompoundStatementObject {
    return CompoundStatementObject.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CompoundStatementObject>, I>>(object: I): CompoundStatementObject {
    const message = createBaseCompoundStatementObject();
    switch (object.compoundStatementObject?.$case) {
      case "declaration": {
        if (
          object.compoundStatementObject?.declaration !== undefined &&
          object.compoundStatementObject?.declaration !== null
        ) {
          message.compoundStatementObject = {
            $case: "declaration",
            declaration: Declaration.fromPartial(object.compoundStatementObject.declaration),
          };
        }
        break;
      }
      case "assignmentExpression": {
        if (
          object.compoundStatementObject?.assignmentExpression !== undefined &&
          object.compoundStatementObject?.assignmentExpression !== null
        ) {
          message.compoundStatementObject = {
            $case: "assignmentExpression",
            assignmentExpression: AssignmentExpression.fromPartial(object.compoundStatementObject.assignmentExpression),
          };
        }
        break;
      }
      case "binaryExpression": {
        if (
          object.compoundStatementObject?.binaryExpression !== undefined &&
          object.compoundStatementObject?.binaryExpression !== null
        ) {
          message.compoundStatementObject = {
            $case: "binaryExpression",
            binaryExpression: BinaryExpression.fromPartial(object.compoundStatementObject.binaryExpression),
          };
        }
        break;
      }
      case "callExpression": {
        if (
          object.compoundStatementObject?.callExpression !== undefined &&
          object.compoundStatementObject?.callExpression !== null
        ) {
          message.compoundStatementObject = {
            $case: "callExpression",
            callExpression: CallExpression.fromPartial(object.compoundStatementObject.callExpression),
          };
        }
        break;
      }
      case "numberLiteral": {
        if (
          object.compoundStatementObject?.numberLiteral !== undefined &&
          object.compoundStatementObject?.numberLiteral !== null
        ) {
          message.compoundStatementObject = {
            $case: "numberLiteral",
            numberLiteral: NumberLiteral.fromPartial(object.compoundStatementObject.numberLiteral),
          };
        }
        break;
      }
      case "reference": {
        if (
          object.compoundStatementObject?.reference !== undefined && object.compoundStatementObject?.reference !== null
        ) {
          message.compoundStatementObject = {
            $case: "reference",
            reference: Reference.fromPartial(object.compoundStatementObject.reference),
          };
        }
        break;
      }
      case "stringLiteral": {
        if (
          object.compoundStatementObject?.stringLiteral !== undefined &&
          object.compoundStatementObject?.stringLiteral !== null
        ) {
          message.compoundStatementObject = {
            $case: "stringLiteral",
            stringLiteral: StringLiteral.fromPartial(object.compoundStatementObject.stringLiteral),
          };
        }
        break;
      }
      case "compoundStatement": {
        if (
          object.compoundStatementObject?.compoundStatement !== undefined &&
          object.compoundStatementObject?.compoundStatement !== null
        ) {
          message.compoundStatementObject = {
            $case: "compoundStatement",
            compoundStatement: CompoundStatement.fromPartial(object.compoundStatementObject.compoundStatement),
          };
        }
        break;
      }
      case "ifStatement": {
        if (
          object.compoundStatementObject?.ifStatement !== undefined &&
          object.compoundStatementObject?.ifStatement !== null
        ) {
          message.compoundStatementObject = {
            $case: "ifStatement",
            ifStatement: IfStatement.fromPartial(object.compoundStatementObject.ifStatement),
          };
        }
        break;
      }
      case "returnStatement": {
        if (
          object.compoundStatementObject?.returnStatement !== undefined &&
          object.compoundStatementObject?.returnStatement !== null
        ) {
          message.compoundStatementObject = {
            $case: "returnStatement",
            returnStatement: ReturnStatement.fromPartial(object.compoundStatementObject.returnStatement),
          };
        }
        break;
      }
      case "comment": {
        if (object.compoundStatementObject?.comment !== undefined && object.compoundStatementObject?.comment !== null) {
          message.compoundStatementObject = {
            $case: "comment",
            comment: Comment.fromPartial(object.compoundStatementObject.comment),
          };
        }
        break;
      }
      case "unknown": {
        if (object.compoundStatementObject?.unknown !== undefined && object.compoundStatementObject?.unknown !== null) {
          message.compoundStatementObject = {
            $case: "unknown",
            unknown: Unknown.fromPartial(object.compoundStatementObject.unknown),
          };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseSourceFile(): SourceFile {
  return { id: "", code: [] };
}

export const SourceFile: MessageFns<SourceFile> = {
  encode(message: SourceFile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    for (const v of message.code) {
      DeclarationObject.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SourceFile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSourceFile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.code.push(DeclarationObject.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SourceFile {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      code: globalThis.Array.isArray(object?.code) ? object.code.map((e: any) => DeclarationObject.fromJSON(e)) : [],
    };
  },

  toJSON(message: SourceFile): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.code?.length) {
      obj.code = message.code.map((e) => DeclarationObject.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SourceFile>, I>>(base?: I): SourceFile {
    return SourceFile.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SourceFile>, I>>(object: I): SourceFile {
    const message = createBaseSourceFile();
    message.id = object.id ?? "";
    message.code = object.code?.map((e) => DeclarationObject.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUnknown(): Unknown {
  return { id: "", content: "" };
}

export const Unknown: MessageFns<Unknown> = {
  encode(message: Unknown, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.content !== "") {
      writer.uint32(18).string(message.content);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Unknown {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnknown();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.content = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Unknown {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
    };
  },

  toJSON(message: Unknown): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Unknown>, I>>(base?: I): Unknown {
    return Unknown.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Unknown>, I>>(object: I): Unknown {
    const message = createBaseUnknown();
    message.id = object.id ?? "";
    message.content = object.content ?? "";
    return message;
  },
};

function createBaseAssignmentExpression(): AssignmentExpression {
  return { id: "", idDeclaration: "", identifier: "", value: undefined };
}

export const AssignmentExpression: MessageFns<AssignmentExpression> = {
  encode(message: AssignmentExpression, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.idDeclaration !== "") {
      writer.uint32(18).string(message.idDeclaration);
    }
    if (message.identifier !== "") {
      writer.uint32(26).string(message.identifier);
    }
    if (message.value !== undefined) {
      ExpressionObject.encode(message.value, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssignmentExpression {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssignmentExpression();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.idDeclaration = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.identifier = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.value = ExpressionObject.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AssignmentExpression {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      idDeclaration: isSet(object.idDeclaration) ? globalThis.String(object.idDeclaration) : "",
      identifier: isSet(object.identifier) ? globalThis.String(object.identifier) : "",
      value: isSet(object.value) ? ExpressionObject.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: AssignmentExpression): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.idDeclaration !== "") {
      obj.idDeclaration = message.idDeclaration;
    }
    if (message.identifier !== "") {
      obj.identifier = message.identifier;
    }
    if (message.value !== undefined) {
      obj.value = ExpressionObject.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AssignmentExpression>, I>>(base?: I): AssignmentExpression {
    return AssignmentExpression.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AssignmentExpression>, I>>(object: I): AssignmentExpression {
    const message = createBaseAssignmentExpression();
    message.id = object.id ?? "";
    message.idDeclaration = object.idDeclaration ?? "";
    message.identifier = object.identifier ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ExpressionObject.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseBinaryExpression(): BinaryExpression {
  return { id: "", left: undefined, operator: "", right: undefined };
}

export const BinaryExpression: MessageFns<BinaryExpression> = {
  encode(message: BinaryExpression, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.left !== undefined) {
      ExpressionObject.encode(message.left, writer.uint32(18).fork()).join();
    }
    if (message.operator !== "") {
      writer.uint32(26).string(message.operator);
    }
    if (message.right !== undefined) {
      ExpressionObject.encode(message.right, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BinaryExpression {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBinaryExpression();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.left = ExpressionObject.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.operator = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.right = ExpressionObject.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BinaryExpression {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      left: isSet(object.left) ? ExpressionObject.fromJSON(object.left) : undefined,
      operator: isSet(object.operator) ? globalThis.String(object.operator) : "",
      right: isSet(object.right) ? ExpressionObject.fromJSON(object.right) : undefined,
    };
  },

  toJSON(message: BinaryExpression): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.left !== undefined) {
      obj.left = ExpressionObject.toJSON(message.left);
    }
    if (message.operator !== "") {
      obj.operator = message.operator;
    }
    if (message.right !== undefined) {
      obj.right = ExpressionObject.toJSON(message.right);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BinaryExpression>, I>>(base?: I): BinaryExpression {
    return BinaryExpression.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BinaryExpression>, I>>(object: I): BinaryExpression {
    const message = createBaseBinaryExpression();
    message.id = object.id ?? "";
    message.left = (object.left !== undefined && object.left !== null)
      ? ExpressionObject.fromPartial(object.left)
      : undefined;
    message.operator = object.operator ?? "";
    message.right = (object.right !== undefined && object.right !== null)
      ? ExpressionObject.fromPartial(object.right)
      : undefined;
    return message;
  },
};

function createBaseCallExpression(): CallExpression {
  return { id: "", idDeclaration: "", identifier: "", argumentList: [] };
}

export const CallExpression: MessageFns<CallExpression> = {
  encode(message: CallExpression, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.idDeclaration !== "") {
      writer.uint32(18).string(message.idDeclaration);
    }
    if (message.identifier !== "") {
      writer.uint32(26).string(message.identifier);
    }
    for (const v of message.argumentList) {
      ExpressionObject.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CallExpression {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCallExpression();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.idDeclaration = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.identifier = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.argumentList.push(ExpressionObject.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CallExpression {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      idDeclaration: isSet(object.idDeclaration) ? globalThis.String(object.idDeclaration) : "",
      identifier: isSet(object.identifier) ? globalThis.String(object.identifier) : "",
      argumentList: globalThis.Array.isArray(object?.argumentList)
        ? object.argumentList.map((e: any) => ExpressionObject.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CallExpression): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.idDeclaration !== "") {
      obj.idDeclaration = message.idDeclaration;
    }
    if (message.identifier !== "") {
      obj.identifier = message.identifier;
    }
    if (message.argumentList?.length) {
      obj.argumentList = message.argumentList.map((e) => ExpressionObject.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CallExpression>, I>>(base?: I): CallExpression {
    return CallExpression.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CallExpression>, I>>(object: I): CallExpression {
    const message = createBaseCallExpression();
    message.id = object.id ?? "";
    message.idDeclaration = object.idDeclaration ?? "";
    message.identifier = object.identifier ?? "";
    message.argumentList = object.argumentList?.map((e) => ExpressionObject.fromPartial(e)) || [];
    return message;
  },
};

function createBaseComment(): Comment {
  return { id: "", content: "" };
}

export const Comment: MessageFns<Comment> = {
  encode(message: Comment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.content !== "") {
      writer.uint32(18).string(message.content);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Comment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.content = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Comment {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
    };
  },

  toJSON(message: Comment): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Comment>, I>>(base?: I): Comment {
    return Comment.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Comment>, I>>(object: I): Comment {
    const message = createBaseComment();
    message.id = object.id ?? "";
    message.content = object.content ?? "";
    return message;
  },
};

function createBaseCompoundStatement(): CompoundStatement {
  return { id: "", codeBlock: [] };
}

export const CompoundStatement: MessageFns<CompoundStatement> = {
  encode(message: CompoundStatement, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    for (const v of message.codeBlock) {
      CompoundStatementObject.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CompoundStatement {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompoundStatement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.codeBlock.push(CompoundStatementObject.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CompoundStatement {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      codeBlock: globalThis.Array.isArray(object?.codeBlock)
        ? object.codeBlock.map((e: any) => CompoundStatementObject.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CompoundStatement): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.codeBlock?.length) {
      obj.codeBlock = message.codeBlock.map((e) => CompoundStatementObject.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CompoundStatement>, I>>(base?: I): CompoundStatement {
    return CompoundStatement.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CompoundStatement>, I>>(object: I): CompoundStatement {
    const message = createBaseCompoundStatement();
    message.id = object.id ?? "";
    message.codeBlock = object.codeBlock?.map((e) => CompoundStatementObject.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDeclaration(): Declaration {
  return { id: "", primitiveType: "", identifier: "", value: undefined };
}

export const Declaration: MessageFns<Declaration> = {
  encode(message: Declaration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.primitiveType !== "") {
      writer.uint32(18).string(message.primitiveType);
    }
    if (message.identifier !== "") {
      writer.uint32(26).string(message.identifier);
    }
    if (message.value !== undefined) {
      ExpressionObject.encode(message.value, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Declaration {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeclaration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.primitiveType = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.identifier = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.value = ExpressionObject.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Declaration {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      primitiveType: isSet(object.primitiveType) ? globalThis.String(object.primitiveType) : "",
      identifier: isSet(object.identifier) ? globalThis.String(object.identifier) : "",
      value: isSet(object.value) ? ExpressionObject.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Declaration): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.primitiveType !== "") {
      obj.primitiveType = message.primitiveType;
    }
    if (message.identifier !== "") {
      obj.identifier = message.identifier;
    }
    if (message.value !== undefined) {
      obj.value = ExpressionObject.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Declaration>, I>>(base?: I): Declaration {
    return Declaration.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Declaration>, I>>(object: I): Declaration {
    const message = createBaseDeclaration();
    message.id = object.id ?? "";
    message.primitiveType = object.primitiveType ?? "";
    message.identifier = object.identifier ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ExpressionObject.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseElseClause(): ElseClause {
  return { id: "", body: undefined };
}

export const ElseClause: MessageFns<ElseClause> = {
  encode(message: ElseClause, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.body !== undefined) {
      CompoundStatementObject.encode(message.body, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ElseClause {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseElseClause();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.body = CompoundStatementObject.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ElseClause {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      body: isSet(object.body) ? CompoundStatementObject.fromJSON(object.body) : undefined,
    };
  },

  toJSON(message: ElseClause): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.body !== undefined) {
      obj.body = CompoundStatementObject.toJSON(message.body);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ElseClause>, I>>(base?: I): ElseClause {
    return ElseClause.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ElseClause>, I>>(object: I): ElseClause {
    const message = createBaseElseClause();
    message.id = object.id ?? "";
    message.body = (object.body !== undefined && object.body !== null)
      ? CompoundStatementObject.fromPartial(object.body)
      : undefined;
    return message;
  },
};

function createBaseFunctionDeclaration(): FunctionDeclaration {
  return { id: "", returnType: "", identifier: "", parameterList: [] };
}

export const FunctionDeclaration: MessageFns<FunctionDeclaration> = {
  encode(message: FunctionDeclaration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.returnType !== "") {
      writer.uint32(18).string(message.returnType);
    }
    if (message.identifier !== "") {
      writer.uint32(26).string(message.identifier);
    }
    for (const v of message.parameterList) {
      FunctionParameter.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunctionDeclaration {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunctionDeclaration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.returnType = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.identifier = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.parameterList.push(FunctionParameter.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunctionDeclaration {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      returnType: isSet(object.returnType) ? globalThis.String(object.returnType) : "",
      identifier: isSet(object.identifier) ? globalThis.String(object.identifier) : "",
      parameterList: globalThis.Array.isArray(object?.parameterList)
        ? object.parameterList.map((e: any) => FunctionParameter.fromJSON(e))
        : [],
    };
  },

  toJSON(message: FunctionDeclaration): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.returnType !== "") {
      obj.returnType = message.returnType;
    }
    if (message.identifier !== "") {
      obj.identifier = message.identifier;
    }
    if (message.parameterList?.length) {
      obj.parameterList = message.parameterList.map((e) => FunctionParameter.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FunctionDeclaration>, I>>(base?: I): FunctionDeclaration {
    return FunctionDeclaration.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FunctionDeclaration>, I>>(object: I): FunctionDeclaration {
    const message = createBaseFunctionDeclaration();
    message.id = object.id ?? "";
    message.returnType = object.returnType ?? "";
    message.identifier = object.identifier ?? "";
    message.parameterList = object.parameterList?.map((e) => FunctionParameter.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFunctionDefinition(): FunctionDefinition {
  return { id: "", returnType: "", identifier: "", parameterList: [], compoundStatement: undefined };
}

export const FunctionDefinition: MessageFns<FunctionDefinition> = {
  encode(message: FunctionDefinition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.returnType !== "") {
      writer.uint32(18).string(message.returnType);
    }
    if (message.identifier !== "") {
      writer.uint32(26).string(message.identifier);
    }
    for (const v of message.parameterList) {
      FunctionParameter.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.compoundStatement !== undefined) {
      CompoundStatement.encode(message.compoundStatement, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunctionDefinition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunctionDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.returnType = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.identifier = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.parameterList.push(FunctionParameter.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.compoundStatement = CompoundStatement.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunctionDefinition {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      returnType: isSet(object.returnType) ? globalThis.String(object.returnType) : "",
      identifier: isSet(object.identifier) ? globalThis.String(object.identifier) : "",
      parameterList: globalThis.Array.isArray(object?.parameterList)
        ? object.parameterList.map((e: any) => FunctionParameter.fromJSON(e))
        : [],
      compoundStatement: isSet(object.compoundStatement)
        ? CompoundStatement.fromJSON(object.compoundStatement)
        : undefined,
    };
  },

  toJSON(message: FunctionDefinition): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.returnType !== "") {
      obj.returnType = message.returnType;
    }
    if (message.identifier !== "") {
      obj.identifier = message.identifier;
    }
    if (message.parameterList?.length) {
      obj.parameterList = message.parameterList.map((e) => FunctionParameter.toJSON(e));
    }
    if (message.compoundStatement !== undefined) {
      obj.compoundStatement = CompoundStatement.toJSON(message.compoundStatement);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FunctionDefinition>, I>>(base?: I): FunctionDefinition {
    return FunctionDefinition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FunctionDefinition>, I>>(object: I): FunctionDefinition {
    const message = createBaseFunctionDefinition();
    message.id = object.id ?? "";
    message.returnType = object.returnType ?? "";
    message.identifier = object.identifier ?? "";
    message.parameterList = object.parameterList?.map((e) => FunctionParameter.fromPartial(e)) || [];
    message.compoundStatement = (object.compoundStatement !== undefined && object.compoundStatement !== null)
      ? CompoundStatement.fromPartial(object.compoundStatement)
      : undefined;
    return message;
  },
};

function createBaseFunctionParameter(): FunctionParameter {
  return { id: "", identifier: "", paramType: "" };
}

export const FunctionParameter: MessageFns<FunctionParameter> = {
  encode(message: FunctionParameter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.identifier !== "") {
      writer.uint32(18).string(message.identifier);
    }
    if (message.paramType !== "") {
      writer.uint32(26).string(message.paramType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunctionParameter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunctionParameter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.identifier = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.paramType = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunctionParameter {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      identifier: isSet(object.identifier) ? globalThis.String(object.identifier) : "",
      paramType: isSet(object.paramType) ? globalThis.String(object.paramType) : "",
    };
  },

  toJSON(message: FunctionParameter): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.identifier !== "") {
      obj.identifier = message.identifier;
    }
    if (message.paramType !== "") {
      obj.paramType = message.paramType;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FunctionParameter>, I>>(base?: I): FunctionParameter {
    return FunctionParameter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FunctionParameter>, I>>(object: I): FunctionParameter {
    const message = createBaseFunctionParameter();
    message.id = object.id ?? "";
    message.identifier = object.identifier ?? "";
    message.paramType = object.paramType ?? "";
    return message;
  },
};

function createBaseIfStatement(): IfStatement {
  return { id: "", condition: undefined, body: undefined, elseStatement: undefined };
}

export const IfStatement: MessageFns<IfStatement> = {
  encode(message: IfStatement, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.condition !== undefined) {
      ExpressionObject.encode(message.condition, writer.uint32(18).fork()).join();
    }
    if (message.body !== undefined) {
      CompoundStatementObject.encode(message.body, writer.uint32(26).fork()).join();
    }
    switch (message.elseStatement?.$case) {
      case "elseIf":
        IfStatement.encode(message.elseStatement.elseIf, writer.uint32(34).fork()).join();
        break;
      case "elseClause":
        ElseClause.encode(message.elseStatement.elseClause, writer.uint32(42).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IfStatement {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIfStatement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.condition = ExpressionObject.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.body = CompoundStatementObject.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.elseStatement = { $case: "elseIf", elseIf: IfStatement.decode(reader, reader.uint32()) };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.elseStatement = { $case: "elseClause", elseClause: ElseClause.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IfStatement {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      condition: isSet(object.condition) ? ExpressionObject.fromJSON(object.condition) : undefined,
      body: isSet(object.body) ? CompoundStatementObject.fromJSON(object.body) : undefined,
      elseStatement: isSet(object.elseIf)
        ? { $case: "elseIf", elseIf: IfStatement.fromJSON(object.elseIf) }
        : isSet(object.elseClause)
        ? { $case: "elseClause", elseClause: ElseClause.fromJSON(object.elseClause) }
        : undefined,
    };
  },

  toJSON(message: IfStatement): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.condition !== undefined) {
      obj.condition = ExpressionObject.toJSON(message.condition);
    }
    if (message.body !== undefined) {
      obj.body = CompoundStatementObject.toJSON(message.body);
    }
    if (message.elseStatement?.$case === "elseIf") {
      obj.elseIf = IfStatement.toJSON(message.elseStatement.elseIf);
    } else if (message.elseStatement?.$case === "elseClause") {
      obj.elseClause = ElseClause.toJSON(message.elseStatement.elseClause);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IfStatement>, I>>(base?: I): IfStatement {
    return IfStatement.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IfStatement>, I>>(object: I): IfStatement {
    const message = createBaseIfStatement();
    message.id = object.id ?? "";
    message.condition = (object.condition !== undefined && object.condition !== null)
      ? ExpressionObject.fromPartial(object.condition)
      : undefined;
    message.body = (object.body !== undefined && object.body !== null)
      ? CompoundStatementObject.fromPartial(object.body)
      : undefined;
    switch (object.elseStatement?.$case) {
      case "elseIf": {
        if (object.elseStatement?.elseIf !== undefined && object.elseStatement?.elseIf !== null) {
          message.elseStatement = { $case: "elseIf", elseIf: IfStatement.fromPartial(object.elseStatement.elseIf) };
        }
        break;
      }
      case "elseClause": {
        if (object.elseStatement?.elseClause !== undefined && object.elseStatement?.elseClause !== null) {
          message.elseStatement = {
            $case: "elseClause",
            elseClause: ElseClause.fromPartial(object.elseStatement.elseClause),
          };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseNumberLiteral(): NumberLiteral {
  return { id: "", value: "" };
}

export const NumberLiteral: MessageFns<NumberLiteral> = {
  encode(message: NumberLiteral, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NumberLiteral {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNumberLiteral();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NumberLiteral {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: NumberLiteral): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NumberLiteral>, I>>(base?: I): NumberLiteral {
    return NumberLiteral.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NumberLiteral>, I>>(object: I): NumberLiteral {
    const message = createBaseNumberLiteral();
    message.id = object.id ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBasePreprocInclude(): PreprocInclude {
  return { id: "", content: "" };
}

export const PreprocInclude: MessageFns<PreprocInclude> = {
  encode(message: PreprocInclude, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.content !== "") {
      writer.uint32(18).string(message.content);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PreprocInclude {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePreprocInclude();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.content = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PreprocInclude {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
    };
  },

  toJSON(message: PreprocInclude): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PreprocInclude>, I>>(base?: I): PreprocInclude {
    return PreprocInclude.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PreprocInclude>, I>>(object: I): PreprocInclude {
    const message = createBasePreprocInclude();
    message.id = object.id ?? "";
    message.content = object.content ?? "";
    return message;
  },
};

function createBaseReference(): Reference {
  return { id: "", declarationId: "", identifier: "" };
}

export const Reference: MessageFns<Reference> = {
  encode(message: Reference, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.declarationId !== "") {
      writer.uint32(18).string(message.declarationId);
    }
    if (message.identifier !== "") {
      writer.uint32(26).string(message.identifier);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Reference {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.declarationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.identifier = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Reference {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      declarationId: isSet(object.declarationId) ? globalThis.String(object.declarationId) : "",
      identifier: isSet(object.identifier) ? globalThis.String(object.identifier) : "",
    };
  },

  toJSON(message: Reference): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.declarationId !== "") {
      obj.declarationId = message.declarationId;
    }
    if (message.identifier !== "") {
      obj.identifier = message.identifier;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Reference>, I>>(base?: I): Reference {
    return Reference.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Reference>, I>>(object: I): Reference {
    const message = createBaseReference();
    message.id = object.id ?? "";
    message.declarationId = object.declarationId ?? "";
    message.identifier = object.identifier ?? "";
    return message;
  },
};

function createBaseReturnStatement(): ReturnStatement {
  return { id: "", value: undefined };
}

export const ReturnStatement: MessageFns<ReturnStatement> = {
  encode(message: ReturnStatement, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.value !== undefined) {
      ExpressionObject.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReturnStatement {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReturnStatement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = ExpressionObject.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReturnStatement {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      value: isSet(object.value) ? ExpressionObject.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: ReturnStatement): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.value !== undefined) {
      obj.value = ExpressionObject.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReturnStatement>, I>>(base?: I): ReturnStatement {
    return ReturnStatement.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReturnStatement>, I>>(object: I): ReturnStatement {
    const message = createBaseReturnStatement();
    message.id = object.id ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ExpressionObject.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseStringLiteral(): StringLiteral {
  return { id: "", value: "" };
}

export const StringLiteral: MessageFns<StringLiteral> = {
  encode(message: StringLiteral, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StringLiteral {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStringLiteral();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StringLiteral {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: StringLiteral): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StringLiteral>, I>>(base?: I): StringLiteral {
    return StringLiteral.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StringLiteral>, I>>(object: I): StringLiteral {
    const message = createBaseStringLiteral();
    message.id = object.id ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
